{
  "all_ballots": {
    "Adrian Farrel": [
      {
        "ad": "Adrian Farrel",
        "end": "2014-01-20 03:37:32-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Adrian Farrel",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-20 03:37:32-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Barry Leiba": [
      {
        "ad": "Barry Leiba",
        "end": "2014-01-21 00:17:41-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Barry Leiba",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-21 00:17:41-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Benoit Claise": [
      {
        "ad": "Benoit Claise",
        "end": "2014-01-22 14:50:09-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Benoit Claise",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-22 14:50:09-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Brian Haberman": [
      {
        "ad": "Brian Haberman",
        "end": "2014-01-06 06:17:23-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Brian Haberman",
        "end": "2014-01-22 12:24:30-08:00",
        "end_reason": "position_updated",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "Yes"
      },
      {
        "ad": "Brian Haberman",
        "end": "2014-01-23 04:34:22-08:00",
        "end_reason": "discuss_updated",
        "start": "2014-01-22 12:24:30-08:00",
        "text": "I am taking the somewhat curious route of raising a DISCUSS on a document that I am shepherding.\u00a0 I will return to a Yes when these issues are resolved.\u00a0 Thomas Narten raised a good point that this document does not mention the work published in RFCs 4436 and 6059 (from the concluded DNA WG).\u00a0 Two of the points he raised are worth addressing in this document prior to publication. 1. If you have stable storage (and many devices do), it makes sense to just cache the addresses instead of regenerating them. DNA does this. Seems like that option should be allowed. (the current document suggests saving the number of DAD iterations in stable storage... why do that if you can just save the address itself?) 2. DNA also has recommendations for detecting when you (re)connect to a network you visited before. That is pretty much the same thing this spec needs to do in order to generate the same addresses when connecting to a previously visited network (i.e., the Network_ID paramater). For the wired case (i.e, no SSID), DNA suggests using the linklayer/linklocal address pair of routers to identify a link. This document might suggest doing the same thing.",
        "type": "Discuss"
      },
      {
        "ad": "Brian Haberman",
        "end": "2014-01-30 14:34:23-08:00",
        "end_reason": "position_updated",
        "start": "2014-01-23 04:34:22-08:00",
        "text": "I am taking the somewhat curious route of raising a DISCUSS on a document that I am shepherding.\u00a0 I will return to a Yes when these issues are resolved.\u00a0 Thomas Narten raised a good point that this document does not mention the work published in RFCs 4436 and 6059 (from the concluded DNA WG).\u00a0 Two of the points he raised are worth addressing in this document prior to publication. 1. [Resolved] - Storing addresses is going to raise privacy issues. 2. DNA provides some ability to manage the Network_ID component of the cryptographic hash.\u00a0 For wired networks, that may be quite useful as long as the Network_ID can be stored securely.",
        "type": "Discuss"
      },
      {
        "ad": "Brian Haberman",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-30 14:34:23-08:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Gonzalo Camarillo": [
      {
        "ad": "Gonzalo Camarillo",
        "end": "2014-01-23 03:50:24-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Gonzalo Camarillo",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-23 03:50:24-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Jari Arkko": [
      {
        "ad": "Jari Arkko",
        "end": "2014-01-21 13:28:49-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Jari Arkko",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-21 13:28:49-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Joel Jaeggli": [
      {
        "ad": "Joel Jaeggli",
        "end": "2014-01-21 18:18:17-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-21 18:18:17-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Martin Stiemerling": [
      {
        "ad": "Martin Stiemerling",
        "end": "2014-01-20 02:10:13-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-20 02:10:13-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Pete Resnick": [
      {
        "ad": "Pete Resnick",
        "end": "2014-01-22 07:57:22-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Pete Resnick",
        "end": "2014-01-22 11:20:14-08:00",
        "end_reason": "position_updated",
        "start": "2014-01-22 07:57:22-08:00",
        "text": "I'd like to hear mostly from the shepherd, who didn't actually answer the second part of the first question on the shepherd writeup: \"Why is this the proper type of RFC?\" This looks to me like an algorithm to generate stable, private, and mostly unique addresses. It looks like it does not affect interoperability at all if people choose a different method. It looks to me like you could have accomplished the same task in a number of different ways. This just seems like a nice method to use if someone wanted to use it. So it's not clear to me why this isn't just an Informational document explaining a nice way to generate stable, private, mostly unique addresses without lots of MUSTs and SHOULDs that are not really interoperability requirements.",
        "type": "Discuss"
      },
      {
        "ad": "Pete Resnick",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-22 11:20:14-08:00",
        "text": "This is an algorithm to generate stable, private, and mostly unique addresses. It does not affect interoperability at all if people choose a different method. Anyone can accomplish the same task in a number of different ways. This is just a nice method to use if someone wanted to use it. This should just be an Informational document explaining a nice way to generate stable, private, mostly unique addresses without all of the MUSTs and SHOULDs, which are not interoperability requirements in the first place. Standardizing this is silly in the extreme.",
        "type": "Abstain"
      }
    ],
    "Richard Barnes": [
      {
        "ad": "Richard Barnes",
        "end": "2014-01-23 03:11:27-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Richard Barnes",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-23 03:11:27-08:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Sean Turner": [
      {
        "ad": "Sean Turner",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      }
    ],
    "Spencer Dawkins": [
      {
        "ad": "Spencer Dawkins",
        "end": "2014-01-23 06:22:03-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Spencer Dawkins",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-23 06:22:03-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Stephen Farrell": [
      {
        "ad": "Stephen Farrell",
        "end": "2014-01-21 07:52:48-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2014-01-22 16:10:30-08:00",
        "end_reason": "discuss_updated",
        "start": "2014-01-21 07:52:48-08:00",
        "text": "(1) Section 5: Why mention only MD5 and SHA1? Why not HMAC-SHA256? As-is, implementers are likely to get this wrong in various ways, e.g. allowing MD5 collisions to be generated on purpose with different inputs perhaps as a way to assign blame to an innocent victim.\u00a0 If HMAC-MD5 or better (*) HMAC-SHA256 were recommended instead, it is far more likley that implementers will do the right thing and it seems just as easy to do today's right thing as what's mentioned here.  \u00a0  (*) Even though HMAC-MD5 is still ok, its better \u00a0  (for audit reasons) if we reduce the number of \u00a0  copies of MD5 runtime code on systems and do not \u00a0  introduce new instances of that code. (2) Why might a sys admin want to display the secret key? If there's a reason shouldn't you say so that coders don't do the wrong thing? The  concern is that once established, this key might be re-used for other purposes and display might then become an interesting attack vector.",
        "type": "Discuss"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2014-01-28 17:58:41-08:00",
        "end_reason": "position_updated",
        "start": "2014-01-22 16:10:30-08:00",
        "text": "(0) Just modifying my disucss to discuss a part of Brian's discuss:-) I'm sure we'll sort it out easily enough though. I very much do not think that it'd be a good plan to store every address that has been generated using this algorithm. That would be making a privacy-enhancing feature damage privacy. See [1] for an example. \u00a0  [1]  http://www.theguardian.com/technology/2011/apr/20/iphone-tracking-prompts-privacy-fears (1) Section 5: Why mention only MD5 and SHA1? Why not HMAC-SHA256? As-is, implementers are likely to get this wrong in various ways, e.g. allowing MD5 collisions to be generated on purpose with different inputs perhaps as a way to assign blame to an innocent victim.\u00a0 If HMAC-MD5 or better (*) HMAC-SHA256 were recommended instead, it is far more likley that implementers will do the right thing and it seems just as easy to do today's right thing as what's mentioned here.  \u00a0  (*) Even though HMAC-MD5 is still ok, its better \u00a0  (for audit reasons) if we reduce the number of \u00a0  copies of MD5 runtime code on systems and do not \u00a0  introduce new instances of that code. (2) Why might a sys admin want to display the secret key? If there's a reason shouldn't you say so that coders don't do the wrong thing? The  concern is that once established, this key might be re-used for other purposes and display might then become an interesting attack vector.",
        "type": "Discuss"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-28 17:58:41-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Stewart Bryant": [
      {
        "ad": "Stewart Bryant",
        "end": "2014-01-21 04:47:15-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stewart Bryant",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-21 04:47:15-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Ted Lemon": [
      {
        "ad": "Ted Lemon",
        "end": "2014-01-22 14:35:03-08:00",
        "end_reason": "new_position",
        "start": "2014-01-06 06:17:23-08:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Ted Lemon",
        "end": "2014-01-30 15:54:46-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-01-22 14:35:03-08:00",
        "text": null,
        "type": "Yes"
      }
    ]
  },
  "doc_name": "rfc7217",
  "evaluation_end": "2014-01-30 15:54:46-08:00",
  "evaluation_start": "2014-01-06 06:17:23-08:00"
}