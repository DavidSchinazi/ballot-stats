{
  "all_ballots": {
    "Adam Roach": [
      {
        "ad": "Adam Roach",
        "end": "2020-03-27 00:00:00+00:00",
        "end_reason": "ad_term_ended",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      }
    ],
    "Alexey Melnikov": [
      {
        "ad": "Alexey Melnikov",
        "end": "2019-08-03 00:23:29-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Alexey Melnikov",
        "end": "2020-03-27 00:00:00+00:00",
        "end_reason": "ad_term_ended",
        "start": "2019-08-03 00:23:29-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Alissa Cooper": [
      {
        "ad": "Alissa Cooper",
        "end": "2019-08-08 06:14:53-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Alissa Cooper",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-08 06:14:53-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Alvaro Retana": [
      {
        "ad": "Alvaro Retana",
        "end": "2019-08-06 15:43:25-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Alvaro Retana",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-06 15:43:25-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Barry Leiba": [
      {
        "ad": "Barry Leiba",
        "end": "2019-08-07 19:54:35-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Barry Leiba",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-07 19:54:35-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Benjamin Kaduk": [
      {
        "ad": "Benjamin Kaduk",
        "end": "2019-08-07 14:44:44-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Benjamin Kaduk",
        "end": "2019-08-22 09:54:54-07:00",
        "end_reason": "position_updated",
        "start": "2019-08-07 14:44:44-07:00",
        "text": "Are the HMAC keys required to be the hash function's block size or its output size?\u00a0 Section 3.1 says just \"the length of each key is exactly the hash size of the associated HMAC algorithm\", and \"hash size\" conventionally refers to the output length.\u00a0 The referenced Section 2 of RFC 2104  concerns itself with the hash's compression function's block size B, which is generally different. Also in Section 3.1, if we are going to claim that a \"random string of sufficient length\" suffices to initialize a fresh index, we need to provide guidance on what constitutes \"sufficient length\" to achieve the needed property. Blake2s is a keyed MAC, but is not an HMAC construction.\u00a0 If we are to allow its usage for providing integrity protection of babel packets directly, we therefore cannot refer to the preotection scheme as \"HMAC\" generically.\u00a0 Fixing this will, unfortunately, be somewhat invasive to the document, since we mention HMAC all over the place.\u00a0 I believe that \"Keyed Message Authentication Code (Keyed MAC)\" is an appropriate replacement description. The suggestion that the large challenge nonce size admits storage of state in a secure \"cookie\" in the nonce is true, however, implementing this properly presents some subtleties, and it seems like something of an attractive nuisance to suggest that it is possible without giving adequate guidance at how to do it safely.\u00a0 Unfortunately, the best reference I can think of, offhand, is the obsoleted  RFC 5077 . Let's also have a discussion about whether 64 bits of randomness is always sufficient; I left a longer note down in the Comment since I don't expect this to end up being a blocking point.",
        "type": "Discuss"
      },
      {
        "ad": "Benjamin Kaduk",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-22 09:54:54-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Deborah Brungard": [
      {
        "ad": "Deborah Brungard",
        "end": "2019-08-05 05:59:32-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Deborah Brungard",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-05 05:59:32-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Eric Vyncke": [
      {
        "ad": "Eric Vyncke",
        "end": "2019-08-05 00:57:01-07:00",
        "end_reason": "position_updated",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Eric Vyncke",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-05 00:57:01-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Erik Kline": [
      {
        "ad": "Erik Kline",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2020-08-17 01:22:48-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Ignas Bagdonas": [
      {
        "ad": "Ignas Bagdonas",
        "end": "2020-03-27 00:00:00+00:00",
        "end_reason": "ad_term_ended",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      }
    ],
    "Magnus Westerlund": [
      {
        "ad": "Magnus Westerlund",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      }
    ],
    "Martin Duke": [
      {
        "ad": "Martin Duke",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2020-04-15 16:42:34-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Martin Vigoureux": [
      {
        "ad": "Martin Vigoureux",
        "end": "2019-07-12 14:34:58-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Martin Vigoureux",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-07-12 14:34:58-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Mirja Kuhlewind": [
      {
        "ad": "Mirja Kuhlewind",
        "end": "2019-08-07 05:16:36-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Mirja Kuhlewind",
        "end": "2019-08-07 05:17:53-07:00",
        "end_reason": "discuss_updated",
        "start": "2019-08-07 05:16:36-07:00",
        "text": "I would like to quickly discuss the following approach taken in section 4.3.1.1: \u00a0  \"Since a challenge may be prompted by a packet replayed by an \u00a0  attacker, a node MUST impose a rate limitation to the challenges it \u00a0  sends; the limit SHOULD default to one challenge request every 300ms, \u00a0  and MAY be configurable.\" While it is important to limit challenge message here, there might be a better approach than static rate-limiting given this is a request-response mechanism. Usually the approach is to only allow for one outstanding request (without) reply and apply some kind of loss detect/termination rule. In your case the easiest approach would be when the 30 sec timer is expired, or if the RTT is know or can be estimated than a value of e.g. 3xRTT could be appropriate as well. Please consider this alternative approach. May also see  RFC8085  for further guidance. Further Appendix A (Incremental deployment and key rotation) contains normative language and therefore should probably be moved into the body of the document.",
        "type": "Discuss"
      },
      {
        "ad": "Mirja Kuhlewind",
        "end": "2019-12-20 08:51:07-08:00",
        "end_reason": "position_updated",
        "start": "2019-08-07 05:17:53-07:00",
        "text": "I would like to quickly discuss the following approach taken in section 4.3.1.1: \u00a0  \"Since a challenge may be prompted by a packet replayed by an \u00a0  attacker, a node MUST impose a rate limitation to the challenges it \u00a0  sends; the limit SHOULD default to one challenge request every 300ms, \u00a0  and MAY be configurable.\" While it is important to limit challenge messages here, there might be a better approach than static rate-limiting given this is a request-response mechanism. Usually the approach is to only allow for one outstanding request (without reply) and apply some kind of loss detect/termination rule. In your case the easiest approach would be when the 30 sec timer is expired, or if the RTT is known (or can be estimated) then a value of e.g. 3xRTT could be appropriate as well. Please consider this alternative approach. Maybe also see  RFC8085  for further guidance. Further Appendix A (Incremental deployment and key rotation) contains normative language and therefore should probably be moved into the body of the document.",
        "type": "Discuss"
      },
      {
        "ad": "Mirja Kuhlewind",
        "end": "2020-03-27 00:00:00+00:00",
        "end_reason": "ad_term_ended",
        "start": "2019-12-20 08:51:07-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Roman Danyliw": [
      {
        "ad": "Roman Danyliw",
        "end": "2019-08-07 12:34:11-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Roman Danyliw",
        "end": "2019-08-07 12:34:53-07:00",
        "end_reason": "discuss_updated",
        "start": "2019-08-07 12:34:11-07:00",
        "text": "A few minor clarifications needed for implementation/precision in the security claims: (1) Section 1.2.\u00a0 Per \u201cany packet accepted as authentic is the exactly copy of a packet originally sent\u201d, this text can be read two ways \u2013 packet as Babel packet or as an IP packet.\u00a0 I think\u00a0 mean the former.\u00a0 Recommend making this clearer as s/any packet/any Babel packet/ (2) Section 2, Per the paragraph, \u201cBy itself, this mechanism is safe against replay \u2026\u201d, please reiterate that for the attack by C to work: A and B must have both lost state; that C is replaying packets with PC previously sent by B (e.g., n+2). (3) Section 4.1.\u00a0 Per \u201cThe node takes the concatenation of the pseudo-header and the packet including the packet header but excluding the packet trailer (from octet 0 inclusive up to (Body Length + 4) exclusive)\u201d, as input for the HMAC.\u00a0 \u201cpacket\u201d is used to sometimes mean IP packet and sometimes a Babel packet carried in an IP packet.\u00a0 As such, the above sentence could be interpretation as: Option #1: HMAC(pseudo-header + the IP header + Babel packet header + Babel packet body \u2013 Babel trailer) Option #2: HMAC(pseudo-header + Babel packet header + Babel packet body) I believe it is option #2.\u00a0 Please be very clear in this text. Other items: (4) Section 2.\u00a0 This section suggests that \u201cone or more HMACs can be appended to the packet\u201d.\u00a0 Under what conditions would it be more than one?\u00a0 What happens if only some of the HMACs are valid?\u00a0 Is use of the same key assumed? (5) Section 4.1.\u00a0 The hash algorithm appears to be negotiated/set out of band (rather than negotiated). The text should explicitly state that somewhere. (6) Section 6.\u00a0 Per \u201cIn particular, reception of a packet with no correct HMAC creates no local state\u00a0 whatsoever\u00a0 (Section 4.3)\u201d, unless this HMAC verification is happening on the NIC, this doesn\u2019t seem sufficiently precise.\u00a0 The \u201cno local state\u201d claim is likely true only as it relates to the tables data structures describes in Section 3.\u00a0 However, the IP and DTLS stack certainly have to account for the packet.",
        "type": "Discuss"
      },
      {
        "ad": "Roman Danyliw",
        "end": "2019-10-17 12:09:42-07:00",
        "end_reason": "position_updated",
        "start": "2019-08-07 12:34:53-07:00",
        "text": "A few minor clarifications needed for implementation/precision in the security claims: (1) Section 1.2.\u00a0 Per \u201cany packet accepted as authentic is the exactly copy of a packet originally sent\u201d, this text can be read two ways \u2013 packet as Babel packet or as an IP packet.\u00a0 I think\u00a0 mean the former.\u00a0 Recommend making this clearer as s/any packet/any Babel packet/ (2) Section 2, Per the paragraph, \u201cBy itself, this mechanism is safe against replay \u2026\u201d, please reiterate that for the attack by C to work: A and B must have both lost state; that C is replaying packets with PC previously sent by B (e.g., n+2). (3) Section 4.1.\u00a0 Per \u201cThe node takes the concatenation of the pseudo-header and the packet including the packet header but excluding the packet trailer (from octet 0 inclusive up to (Body Length + 4) exclusive)\u201d, as input for the HMAC.\u00a0 \u201cpacket\u201d is used to sometimes mean IP packet and sometimes a Babel packet carried in an IP packet.\u00a0 As such, the above sentence could be interpretation as: Option #1: HMAC(pseudo-header + the IP header + Babel packet header + Babel packet body) Option #2: HMAC(pseudo-header + Babel packet header + Babel packet body) I believe it is option #2.\u00a0 Please be very clear in this text. Other items: (4) Section 2.\u00a0 This section suggests that \u201cone or more HMACs can be appended to the packet\u201d.\u00a0 Under what conditions would it be more than one?\u00a0 What happens if only some of the HMACs are valid?\u00a0 Is use of the same key assumed? (5) Section 4.1.\u00a0 The hash algorithm appears to be negotiated/set out of band (rather than negotiated). The text should explicitly state that somewhere. (6) Section 6.\u00a0 Per \u201cIn particular, reception of a packet with no correct HMAC creates no local state\u00a0 whatsoever\u00a0 (Section 4.3)\u201d, unless this HMAC verification is happening on the NIC, this doesn\u2019t seem sufficiently precise.\u00a0 The \u201cno local state\u201d claim is likely true only as it relates to the tables data structures describes in Section 3.\u00a0 However, the IP and DTLS stack certainly have to account for the packet.",
        "type": "Discuss"
      },
      {
        "ad": "Roman Danyliw",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-10-17 12:09:42-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Suresh Krishnan": [
      {
        "ad": "Suresh Krishnan",
        "end": "2019-08-08 05:50:04-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Suresh Krishnan",
        "end": "2020-03-27 00:00:00+00:00",
        "end_reason": "ad_term_ended",
        "start": "2019-08-08 05:50:04-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Warren Kumari": [
      {
        "ad": "Warren Kumari",
        "end": "2019-08-07 13:50:55-07:00",
        "end_reason": "new_position",
        "start": "2019-07-12 14:34:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Warren Kumari",
        "end": "2020-09-08 09:32:27-07:00",
        "end_reason": "evaluation_closed",
        "start": "2019-08-07 13:50:55-07:00",
        "text": null,
        "type": "No Objection"
      }
    ]
  },
  "doc_name": "rfc8967",
  "evaluation_end": "2020-09-08 09:32:27-07:00",
  "evaluation_start": "2019-07-12 14:34:57-07:00"
}