{
  "all_ballots": {
    "Adrian Farrel": [
      {
        "ad": "Adrian Farrel",
        "end": "2014-10-28 02:52:14-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Adrian Farrel",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-28 02:52:14-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Alia Atlas": [
      {
        "ad": "Alia Atlas",
        "end": "2014-10-30 08:29:58-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Alia Atlas",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 08:29:58-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Alissa Cooper": [
      {
        "ad": "Alissa Cooper",
        "end": "2014-10-28 16:13:58-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Alissa Cooper",
        "end": "2014-12-23 10:12:11-08:00",
        "end_reason": "position_updated",
        "start": "2014-10-28 16:13:58-07:00",
        "text": "= Section 3.2.3 = If I'm reading the document correctly, when searching for an entity, the search pattern is expected to represent an entity using the syntax specified in Section 6.1 of draft-ietf-weirds-json-response. But when the path segment is provided, rather than a search, Section 3.1.5 says this: \u00a0  The\u00a0 parameter represents an entity (such as a contact, \u00a0  registrant, or registrar) identifier whose syntax is specific to the \u00a0  registration provider.\u00a0 For example, for some DNRs contact \u00a0  identifiers are specified in  RFC 5730  [ RFC5730 ] and  RFC 5733 \u00a0  [ RFC5733 ]. This makes it seem as if an entity in a path segment uses different syntax (actually, non-standard syntax that is up to the registration provider) than an entity that someone might search for. Is there some specific field in the entity definition in  draft-ietf-weirds-json-response  that\u00a0 is supposed to correspond to? Aren't HTTP GETs for both path segments and searches meant to provide responses based on the same underlying data? If so, I don't understand why there is a specified syntax for entities in one but not the other. This also seems inconsistent with the following text in Section 6.1 of  draft-ietf-weirds-json-response : \u00a0  The entity object class appears throughout this document and is an \u00a0  appropriate response for the /entity/XXXX query defined in \u00a0  Registration Data Access Protocol Lookup Format \u00a0  [ I-D.ietf-weirds-rdap-query ]",
        "type": "Discuss"
      },
      {
        "ad": "Alissa Cooper",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-12-23 10:12:11-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Barry Leiba": [
      {
        "ad": "Barry Leiba",
        "end": "2014-10-28 23:37:00-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Barry Leiba",
        "end": "2014-12-23 10:17:11-08:00",
        "end_reason": "position_updated",
        "start": "2014-10-28 23:37:00-07:00",
        "text": "-- Section 3.2.1 -- None of the syntaxes begin with \"/\", and then you have a examples that do.\u00a0 Probably should take the \"/\" off the examples, no?\u00a0 But I see that the json-response document also uses the leading slash.\u00a0 But but, the bootstrapping document says that the URLs MUST end with slashes, because query specifications are appended to them (therefore the query specifications don't begin with slashes).\u00a0 This all seems somewhat inconsistent.",
        "type": "Discuss"
      },
      {
        "ad": "Barry Leiba",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-12-23 10:17:11-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Benoit Claise": [
      {
        "ad": "Benoit Claise",
        "end": "2014-10-29 05:53:28-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Benoit Claise",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-29 05:53:28-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Brian Haberman": [
      {
        "ad": "Brian Haberman",
        "end": "2014-10-28 06:53:13-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Brian Haberman",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-28 06:53:13-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Jari Arkko": [
      {
        "ad": "Jari Arkko",
        "end": "2014-10-30 05:24:45-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Jari Arkko",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 05:24:45-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Joel Jaeggli": [
      {
        "ad": "Joel Jaeggli",
        "end": "2014-10-30 00:42:50-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 00:42:50-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Kathleen Moriarty": [
      {
        "ad": "Kathleen Moriarty",
        "end": "2014-10-29 13:01:39-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Kathleen Moriarty",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-29 13:01:39-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Martin Stiemerling": [
      {
        "ad": "Martin Stiemerling",
        "end": "2014-10-29 13:21:07-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-29 13:21:07-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Pete Resnick": [
      {
        "ad": "Pete Resnick",
        "end": "2014-10-27 15:51:27-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Pete Resnick",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Richard Barnes": [
      {
        "ad": "Richard Barnes",
        "end": "2014-10-30 00:10:34-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Richard Barnes",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 00:10:34-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Spencer Dawkins": [
      {
        "ad": "Spencer Dawkins",
        "end": "2014-10-30 07:23:26-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Spencer Dawkins",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 07:23:26-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Stephen Farrell": [
      {
        "ad": "Stephen Farrell",
        "end": "2014-10-30 06:49:42-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-10-30 06:49:42-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Ted Lemon": [
      {
        "ad": "Ted Lemon",
        "end": "2014-10-29 11:47:34-07:00",
        "end_reason": "new_position",
        "start": "2014-10-27 15:51:27-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Ted Lemon",
        "end": "2014-10-29 16:57:04-07:00",
        "end_reason": "discuss_updated",
        "start": "2014-10-29 11:47:34-07:00",
        "text": "Point 1: In section 3.1.1, it's not clear which of three alternative things you may have been specifying: (1) the ASCII representation of the IP address is intended to be converted to binary before use, (2) the ASCII representation is intended to be used directly, or (3) whether the IP address is converted to binary prior to use is an implementation choice.\u00a0  If (1) is what's intended, you should say so explicitly.\u00a0  If either (2) or (3) is intended, then the representation that's used needs to be in some canonical form, and the text as written does not ensure that it will be. So to address this discuss, you should either update the text to say that (1) is what's intended, and it won't work otherwise, or you need to require, not suggest, a canonical representation.\u00a0  If you go with the second option, your reference to  RFC 5952  isn't adequate: you need to specifically reference section 4, and specifically exclude section 5.\u00a0  I have no preference as to how you resolve this. Point 2: In 3.1.3, the instructions as given don't really guide implementations toward interoperability.\u00a0  Why not just say that servers SHOULD either convert a-labels to u-labels, or u-labels to a-labels, and be done with it?\u00a0  It's not like it's a difficult conversion, and they have to do the conversion to do the comparison, unless for some reason they store both A- and U-labels as keys in their database, which seems really unlikely.\u00a0  The recommendations are written are so vague that I would expect interoperability to only be likely in the case of queries that contain no IDN labels.\u00a0  I wouldn't mind this in an Informational document, but it's pretty sketchy in a standards-track document. It's particularly weird that in one place you say \"An RDAP server that receives a query string with a mixture of A-labels and U-labels MAY convert all the U-labels to A-labels, perform IDNA processing, and proceed with exact-match lookup\" and then in the next paragraph you say \"The server MAY perform the match using either the A-label or U-label form.\u00a0 Using one consistent form for matching every label is likely to be more reliable.\" I'm not sure how to resolve this.\u00a0  I think there's some underlying decision the working group has made that led to this language, but the lack of consistency I mention above leads me to wonder if either that decision wasn't very clear, or the document failed to reflect it.\u00a0  Interestingly, 3.1.4 is written as if 3.1.3 gives clear guidance as to how IDNs are represented. In 3.2.1 and 3.2.2, the main use cases I can see for nameserver searches are for spammers to identify related domains, and for eavesdroppers to do the same.\u00a0  What's the motivation for including these capabilities?\u00a0  At a minimum, the privacy considerations for this search ought to be discussed in a privacy considerations section or in the security considerations section. Point 3: In 4.1, you don't actually specify the syntax for partial string matches.\u00a0  I think I can intuit what you mean, but you should be explicit, and you shouldn't suggest using POSIX regex searches unless that's what you really mean; if that's what you really mean, then you need to do a lot more work than you've done.\u00a0  I _think_ what you intend is to simply say that if one or more asterisks appear in a label, then when the search is done, any label that contains the non-asterisk characters in sequence plus zero or more characters in sequence in place of each asterisk would match.\u00a0  But you don't actually say that, so I'm not sure what you actually intended.\u00a0  The text could be read to mean that any arbitrary search mechanism is allowed, but if that's the case then you need to go into a lot more detail about the caveats, such as the '.' character in posix regexps and the start and end markers. The text on partial matches for unicode also seems unnecessarily complicated, and likely not implementable without massive knowledge of all the various unicode character sets, which I would not expect an implementation to bother with.\u00a0  It seems relatively harmless to allow searches on combining characters, particularly since it would be a lot of work to prevent it.\u00a0  For example, a search for *\u0f40\u0f0b would not find all instances of a syllable that starts with the sound \"ka\" because ka can be either a head letter or subjoined, but a user might search first using the head letter and then the subjoined letter if (as is not unlikely) he or she were unsure of the correct spelling.\u00a0  It would be a shame if such a search were rendered impossible by an overly-thorough implementation of the current text. As I say, I don't really know what was intended here, so I can't make a definite suggestion as to what the right thing to do is to fix this; I think we just need to discuss it, hence the discuss point.",
        "type": "Discuss"
      },
      {
        "ad": "Ted Lemon",
        "end": "2014-10-29 17:00:15-07:00",
        "end_reason": "discuss_updated",
        "start": "2014-10-29 16:57:04-07:00",
        "text": "Point 1: In section 3.1.1, it's not clear which of three alternative things you may have been specifying: (1) the ASCII representation of the IP address is intended to be converted to binary before use, (2) the ASCII representation is intended to be used directly, or (3) whether the IP address is converted to binary prior to use is an implementation choice.\u00a0  If (1) is what's intended, you should say so explicitly.\u00a0  If either (2) or (3) is intended, then the representation that's used needs to be in some canonical form, and the text as written does not ensure that it will be. So to address this discuss, you should either update the text to say that (1) is what's intended, and it won't work otherwise, or you need to require, not suggest, a canonical representation.\u00a0  If you go with the second option, your reference to  RFC 5952  isn't adequate: you need to specifically reference section 4, and specifically exclude section 5.\u00a0  I have no preference as to how you resolve this. [point 2 moved to comment] Point 3: In 4.1, you don't actually specify the syntax for partial string matches.\u00a0  I think I can intuit what you mean, but you should be explicit, and you shouldn't suggest using POSIX regex searches unless that's what you really mean; if that's what you really mean, then you need to do a lot more work than you've done.\u00a0  I _think_ what you intend is to simply say that if one or more asterisks appear in a label, then when the search is done, any label that contains the non-asterisk characters in sequence plus zero or more characters in sequence in place of each asterisk would match.\u00a0  But you don't actually say that, so I'm not sure what you actually intended.\u00a0  The text could be read to mean that any arbitrary search mechanism is allowed, but if that's the case then you need to go into a lot more detail about the caveats, such as the '.' character in posix regexps and the start and end markers. The text on partial matches for unicode also seems unnecessarily complicated, and likely not implementable without massive knowledge of all the various unicode character sets, which I would not expect an implementation to bother with.\u00a0  It seems relatively harmless to allow searches on combining characters, particularly since it would be a lot of work to prevent it.\u00a0  For example, a search for *\u0f40\u0f0b would not find all instances of a syllable that starts with the sound \"ka\" because ka can be either a head letter or subjoined, but a user might search first using the head letter and then the subjoined letter if (as is not unlikely) he or she were unsure of the correct spelling.\u00a0  It would be a shame if such a search were rendered impossible by an overly-thorough implementation of the current text. As I say, I don't really know what was intended here, so I can't make a definite suggestion as to what the right thing to do is to fix this; I think we just need to discuss it, hence the discuss point.",
        "type": "Discuss"
      },
      {
        "ad": "Ted Lemon",
        "end": "2014-12-12 13:32:03-08:00",
        "end_reason": "position_updated",
        "start": "2014-10-29 17:00:15-07:00",
        "text": "Point 1: In section 3.1.1, it's not clear which of three alternative things you may have been specifying: (1) the ASCII representation of the IP address is intended to be converted to binary before use, (2) the ASCII representation is intended to be used directly, or (3) whether the IP address is converted to binary prior to use is an implementation choice.\u00a0  If (1) is what's intended, you should say so explicitly.\u00a0  If either (2) or (3) is intended, then the representation that's used needs to be in some canonical form, and the text as written does not ensure that it will be. So to address this discuss, you should either update the text to say that (1) is what's intended, and it won't work otherwise, or you need to require, not suggest, a canonical representation.\u00a0  If you go with the second option, your reference to  RFC 5952  isn't adequate: you need to specifically reference section 4, and specifically exclude section 5.\u00a0  I have no preference as to how you resolve this. Point 2: In 3.1.3, the instructions as given don't really guide implementations toward interoperability.\u00a0  Why not just say that servers SHOULD either convert a-labels to u-labels, or u-labels to a-labels, and be done with it?\u00a0  It's not like it's a difficult conversion, and they have to do the conversion to do the comparison, unless for some reason they store both A- and U-labels as keys in their database, which seems really unlikely.\u00a0  The recommendations are written are so vague that I would expect interoperability to only be likely in the case of queries that contain no IDN labels.\u00a0  I wouldn't mind this in an Informational document, but it's pretty sketchy in a standards-track document. It's particularly weird that in one place you say \"An RDAP server that receives a query string with a mixture of A-labels and U-labels MAY convert all the U-labels to A-labels, perform IDNA processing, and proceed with exact-match lookup\" and then in the next paragraph you say \"The server MAY perform the match using either the A-label or U-label form.\u00a0 Using one consistent form for matching every label is likely to be more reliable.\" I'm not sure how to resolve this.\u00a0  I think there's some underlying decision the working group has made that led to this language, but the lack of consistency I mention above leads me to wonder if either that decision wasn't very clear, or the document failed to reflect it.\u00a0  Interestingly, 3.1.4 is written as if 3.1.3 gives clear guidance as to how IDNs are represented. [point 2', which I forgot to label as a separate point, has been moved moved to a comment] Point 3: In 4.1, you don't actually specify the syntax for partial string matches.\u00a0  I think I can intuit what you mean, but you should be explicit, and you shouldn't suggest using POSIX regex searches unless that's what you really mean; if that's what you really mean, then you need to do a lot more work than you've done.\u00a0  I _think_ what you intend is to simply say that if one or more asterisks appear in a label, then when the search is done, any label that contains the non-asterisk characters in sequence plus zero or more characters in sequence in place of each asterisk would match.\u00a0  But you don't actually say that, so I'm not sure what you actually intended.\u00a0  The text could be read to mean that any arbitrary search mechanism is allowed, but if that's the case then you need to go into a lot more detail about the caveats, such as the '.' character in posix regexps and the start and end markers. The text on partial matches for unicode also seems unnecessarily complicated, and likely not implementable without massive knowledge of all the various unicode character sets, which I would not expect an implementation to bother with.\u00a0  It seems relatively harmless to allow searches on combining characters, particularly since it would be a lot of work to prevent it.\u00a0  For example, a search for *\u0f40\u0f0b would not find all instances of a syllable that starts with the sound \"ka\" because ka can be either a head letter or subjoined, but a user might search first using the head letter and then the subjoined letter if (as is not unlikely) he or she were unsure of the correct spelling.\u00a0  It would be a shame if such a search were rendered impossible by an overly-thorough implementation of the current text. As I say, I don't really know what was intended here, so I can't make a definite suggestion as to what the right thing to do is to fix this; I think we just need to discuss it, hence the discuss point.",
        "type": "Discuss"
      },
      {
        "ad": "Ted Lemon",
        "end": "2015-01-01 15:16:04-08:00",
        "end_reason": "evaluation_closed",
        "start": "2014-12-12 13:32:03-08:00",
        "text": null,
        "type": "No Objection"
      }
    ]
  },
  "doc_name": "rfc7482",
  "evaluation_end": "2015-01-01 15:16:04-08:00",
  "evaluation_start": "2014-10-27 15:51:27-07:00"
}