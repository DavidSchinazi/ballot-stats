{
  "all_ballots": {
    "Adrian Farrel": [
      {
        "ad": "Adrian Farrel",
        "end": "2013-10-09 06:11:05-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Adrian Farrel",
        "end": "2013-11-15 06:44:19-08:00",
        "end_reason": "position_updated",
        "start": "2013-10-09 06:11:05-07:00",
        "text": "This is a fine document, but I have concluded (see below) that it is not the document it says it is. That causes me to place a Discuss that I think can be very easily fixed by some minor changes to the text... In Section 1 \u00a0  Load distribution is a slightly \u00a0  more general term than load balancing, but the latter is more \u00a0  commonly used.\u00a0 Both terms refer to mechanisms that distribute the \u00a0  workload of a server farm among different servers in order to \u00a0  optimize performance. In the context of server farms, the terms definitely apply as you describe, but it is not right to say that load balancing means a mechanism used to the distribute workload of a server farm. Please reword to not curtail other people's use of the term. It may be enough to say \"Both terms can be used to refer to...\" or \"In this document, both terms are used to refer to...\" or \"In the context of a server farm, both terms refer to...\" Similarly, Section 3 is headed \"Summary of Load Balancing Techniques\" but appears to be about load balancing techniques for server farms. So maybe that should be rebranded. Which leads me to ask the main meat of the Discussable point: is the  document title correct? Shouldn't it be \"Using the IPv6 Flow Label for  Server Load Balancing in Server Farms\"?",
        "type": "Discuss"
      },
      {
        "ad": "Adrian Farrel",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-11-15 06:44:19-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Barry Leiba": [
      {
        "ad": "Barry Leiba",
        "end": "2013-10-08 11:52:10-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Barry Leiba",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-08 11:52:10-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Benoit Claise": [
      {
        "ad": "Benoit Claise",
        "end": "2013-10-08 14:17:57-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Benoit Claise",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-08 14:17:57-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Brian Haberman": [
      {
        "ad": "Brian Haberman",
        "end": "2013-10-08 07:48:22-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Brian Haberman",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-08 07:48:22-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Gonzalo Camarillo": [
      {
        "ad": "Gonzalo Camarillo",
        "end": "2013-10-10 08:07:46-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Gonzalo Camarillo",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-10 08:07:46-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Jari Arkko": [
      {
        "ad": "Jari Arkko",
        "end": "2013-10-09 14:28:53-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Jari Arkko",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-09 14:28:53-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Joel Jaeggli": [
      {
        "ad": "Joel Jaeggli",
        "end": "2013-10-10 00:07:59-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2013-10-10 00:12:58-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-10-10 00:07:59-07:00",
        "text": "this\u00a0 started as a comment. it's bloomed into a discuss because I think there's a lot of issues to be dicussed. \u00a0  If the flow label is in fact set to zero, it will not \u00a0  affect the information entropy of the IPv6 header. certainly it will, since your assumption vis-a-vis label balancing is that it does augment (an l3 only hash)\u00a0 or\u00a0 substitute for entropy that might otherwise be found elsewhere, e.g. in the transport header. Assume the case of load balancing a small number of sources to a single or small number of destination IPs (this is common for API services for example or lots of front-end --> back-backend application communication). host 1 first tcp connection to dest 1 with a zero flow label using a source, dest, flow label, xor hashes to the same host behind dest 1 as host 1 second connection to dest 2 with a zero flow label. That's peachy if that's what you want, but not if you don't. so as you note if you're using zero you probably want to do something else. ... these two: \u00a0 o\u00a0 Another method, for HTTP servers, is to operate a layer 7 reverse \u00a0 \u00a0 \u00a0 proxy in front of the server farm.\u00a0 The reverse proxy will present \u00a0 \u00a0 \u00a0 a single IP address to the world, communicated to clients by a \u00a0 \u00a0 \u00a0 single AAAA record.\u00a0 For each new client session (an incoming TCP \u00a0 \u00a0 \u00a0 connection and HTTP request), it will pick a particular server and \u00a0 \u00a0 \u00a0 proxy the session to it.\u00a0 The act of proxying should be more \u00a0 \u00a0 \u00a0 efficient and less resource-intensive than the act of serving the \u00a0 \u00a0 \u00a0 required content.\u00a0 The proxy must retain TCP state and proxy state \u00a0 \u00a0 \u00a0 for the duration of the session.\u00a0 This TCP state could, \u00a0 \u00a0 \u00a0 potentially, include the incoming flow label value. \u00a0  o\u00a0 A component of some load balancing systems is an SSL reverse proxy \u00a0 \u00a0 \u00a0 farm.\u00a0 The individual SSL proxies handle all cryptographic aspects \u00a0 \u00a0 \u00a0 and exchange unencrypted HTTP with the actual servers.\u00a0 Thus, from \u00a0 \u00a0 \u00a0 the load balancing point of view, this really looks just like a \u00a0 \u00a0 \u00a0 server farm, except that it's specialised for HTTPS.\u00a0 Each proxy \u00a0 \u00a0 \u00a0 will retain SSL and TCP and maybe HTTP state for the duration of \u00a0 \u00a0 \u00a0 the session, and the TCP state could potentially include the flow \u00a0 \u00a0 \u00a0 label. are simply variations of application aware proxy they could just as easy be imap(s) or smtp(s) or sip. The operative issue being that for the purposes of connection termination they are hosts not routers and they have to find the upper layer header (and potentially go as far as application protocol implementation). ... \u00a0 \u00a0 \u00a0 In all cases, the layer 3/4 load balancer has to \u00a0 \u00a0 \u00a0 recognize incoming packets as belonging to new or existing client \u00a0 \u00a0 \u00a0 sessions, and choose the target server or proxy so as to ensure \u00a0 \u00a0 \u00a0 persistence. I get what you're trying to say but I think this is a a mis-statement. As you go on to deal with stateless load balancing correctly... A stateless L3+L4 load balancer doesn't care whether a connection is new or preexisting, persistence is product of the values associated with the hash being immutable over the duration for which they are required and no other condition. ... 1.\u00a0 Balancers use various techniques to redirect traffic to a \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 specific target server. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - All servers are configured with the same IP address, they \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 are all on the same LAN, and the load balancer sends directly \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to their individual MAC addresses.\u00a0 In this case, return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets from the server to the client are sent back without \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 passing through the balancer, a technique known as direct \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 server return, but we are not concerned here with the return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer uses an \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IP-in-IP tunnel to reach it. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 performs NAPT (network address and port translation) to \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 deliver the client's packets to that address. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 The choice between these methods is not affected by use of the \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 flow label. You missed one that is rather common which is that there are multiple L3 next-hops\u00a0 for the same destination IP (Layer-3 ECMP the same as is used to hash across router links). that's anycast in it's simplest form, and it's a pretty common technique using either bgp or an IGP of your choice. ... jjaeggli@ca2-b2-re1# run show route 2620:102:8003:211::1/128 inet6.0: 14896 destinations, 59622 routes (14896 active, 0 holddown, 29172 hidden) + = Active Route, - = Last Active, * = Both 2620:102:8003:211::1/128 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  *[BGP/170] 17w6d 23:34:12, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::8 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:21, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:28, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:06, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:08, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:27, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 1d 05:58:20, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:34:38, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:33:43, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 20:20:44, MED 50, localpref 200, from 2620:102:8003::1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 ... \u00a0 \u00a0 \u00a0 2.\u00a0 A layer 3/4 balancer must correctly handle Path MTU Discovery \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 by forwarding relevant ICMPv6 packets in both directions. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 This too is not affected by use of the flow label. icmp messages (this applies to v4 and v6) emitted by devices on the path from the server --> client that are sent back to the server IP are really problematic because the probability of them hashing to a different server is rather high, icmp messages emitted towards the client by path elements inclusive of the server ip are generally no problem. There are techniques to address that e.g. multicasting them towards the servers but that's rather non-scalable. One could snarf the flow label and the source address off the offending packet (the one that's going back in the icmp6 type 2 payload) and use those as the source\u00a0 and flow label for your icmpv6 ptb message since label-balance would insure delivery but that makes diagnostics kind of sketchy. ... diagram in section 3 \u00a0 \u00a0 \u00a0 \u00a0  ___|_______DNS-based____________|___ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  load splitting\u00a0 \u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  (if used) occurs\u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  here\u00a0 \u00a0  dns based sever selection is actually something that occurs on a nameserver (the GTM) the client (e.g. when more than one record is served) or both e.g. by a GTM serving more that one RR. mb-aye:~ jjaeggli$ host  www.google.com www.google.com  has address 173.194.33.18 www.google.com  has address 173.194.33.16 www.google.com  has address 173.194.33.20 www.google.com  has address 173.194.33.19 www.google.com  has address 173.194.33.17 www.google.com  has IPv6 address 2607:f8b0:400a:800::1010 .... \u00a0  However, usage by the proxies seems unlikely to be cost-effective, \u00a0  because they must in any case process the application layer header, \u00a0  so in this document we focus only on layer 3/4 balancers. As you note previously the flow label is in a fixed location in the\u00a0 ip header, so cost isn't really that germain. They do have to look all the way in-to the application so it may not be that relevant. ... \u00a0  o\u00a0 We are only concerned with IPv6 traffic in which the flow label \u00a0 \u00a0 \u00a0 value has been set at or near the source according to [ RFC6437 ]. I can't see that it matters so long as it doesn't change midflow,\u00a0 it's hard to know this with certainty since it's not immutable. ... section 4 \u00a0 2-tuple {source address, flow label}  What would be the gain in not using the source/dest/flow label on a stateless LB? you may be asserting that the dest has low entropy and maybe it does if you only have one, but if you have hundreds or thousands it may well. The destination is required for the forwarding decision your might as well xor-across it too (and traditional layer-3 only load balancing in v4 typically used at least source/dest and generally protocol number). doing so has no state. ... \u00a0 \u00a0 \u00a0 A stateful layer 3/4 load balancer would apply its usual load \u00a0 \u00a0 \u00a0 distribution algorithm to the first packet of a session, and store \u00a0 \u00a0 \u00a0 the {2-tuple, server} association in a table so that subsequent \u00a0 \u00a0 \u00a0 packets belonging to the same session are forwarded to the same \u00a0 \u00a0 \u00a0 server.\u00a0 Thus, for all subsequent packets of the session, it can \u00a0 \u00a0 \u00a0 ignore all IPv6 extension headers, which should lead to a \u00a0 \u00a0 \u00a0 performance benefit.\u00a0 Whether this benefit is valuable will depend \u00a0 \u00a0 \u00a0 on engineering details of the specific load balancer. This strikes me as a bit odd, as described it would be trivial to multiplex another connection\u00a0 over this state entry (which might be desirable for some applications) simply by using the same source/dest/flow label which sounds like a huge DOS risk e.g. because you now have a fixed state entry pinned to a server so long as you keep sending packets.\u00a0 It might also allow you bypass controls that you could apply to the first packet of each session, like for example initiating a new connection to a different destination port number. The other question is how do you know when the session ends. since you're not looking for fin/ack/fin/ack or RST your basically stuck keeping state with a timer or this state table will always be full. This is not as the security considerations section states: \u00a0 The flow label does not significantly alter this situation. with regard to dos/bypass risk. Rather techniques used today by stateful l3/l4 load balancers to mitigate dos risk statelessly to protect servers from large packet flows e.g. TCP syn cookies or apply gross security controls e.g. only port 80 connections for example) become ineffective because the attacker generating valid connections can know in advance what source/dest/flow label(s) will be used by to create connections through which packets can be delivered to servers (which is a rather different problem then it being hard to guess what someone else is using).  ... \u00a0  Since the \u00a0  only state to be stored is the 2-tuple and the server identifier, \u00a0  storage requirements will be reduced.  and a timer apparently, either the 2 minute one from 3697 if we consider that still in force since 6437 doesn't mention it, or some other one.  ... \u00a0 The association between the flow label value and \u00a0  the server is stored in a table (often called stick table) so that \u00a0  future connections using the same flow label can be sent to the same \u00a0  server. This presumes the reuse of flow labels by a client. while 6437 presumes the existence of stateful flow label usage models, state entries that\u00a0 last a long time relative to the tcp connections that use them are an expensive proposition for a network device.",
        "type": "Discuss"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2013-11-03 08:54:20-08:00",
        "end_reason": "discuss_updated",
        "start": "2013-10-10 00:12:58-07:00",
        "text": "this\u00a0 started as a comment. it's bloomed into a discuss because I think there's a lot of issues to be dicussed. (sorry, one minor edit, read the second discuss email rather than the first) \u00a0  If the flow label is in fact set to zero, it will not \u00a0  affect the information entropy of the IPv6 header. certainly it will, since your assumption vis-a-vis label balancing is that it does augment (an l3 only hash)\u00a0 or\u00a0 substitute for entropy that might otherwise be found elsewhere, e.g. in the transport header. Assume the case of load balancing a small number of sources to a single or small number of destination IPs (this is common for API services for example or lots of front-end --> back-backend application communication). host 1 first tcp connection to dest 1 with a zero flow label using a source, dest, flow label, xor hashes to the same host behind dest 1 as host 1 second connection to dest 2 with a zero flow label. That's peachy if that's what you want, but not if you don't. so as you note if you're using zero you probably want to do something else. ... these two: \u00a0 o\u00a0 Another method, for HTTP servers, is to operate a layer 7 reverse \u00a0 \u00a0 \u00a0 proxy in front of the server farm.\u00a0 The reverse proxy will present \u00a0 \u00a0 \u00a0 a single IP address to the world, communicated to clients by a \u00a0 \u00a0 \u00a0 single AAAA record.\u00a0 For each new client session (an incoming TCP \u00a0 \u00a0 \u00a0 connection and HTTP request), it will pick a particular server and \u00a0 \u00a0 \u00a0 proxy the session to it.\u00a0 The act of proxying should be more \u00a0 \u00a0 \u00a0 efficient and less resource-intensive than the act of serving the \u00a0 \u00a0 \u00a0 required content.\u00a0 The proxy must retain TCP state and proxy state \u00a0 \u00a0 \u00a0 for the duration of the session.\u00a0 This TCP state could, \u00a0 \u00a0 \u00a0 potentially, include the incoming flow label value. \u00a0  o\u00a0 A component of some load balancing systems is an SSL reverse proxy \u00a0 \u00a0 \u00a0 farm.\u00a0 The individual SSL proxies handle all cryptographic aspects \u00a0 \u00a0 \u00a0 and exchange unencrypted HTTP with the actual servers.\u00a0 Thus, from \u00a0 \u00a0 \u00a0 the load balancing point of view, this really looks just like a \u00a0 \u00a0 \u00a0 server farm, except that it's specialised for HTTPS.\u00a0 Each proxy \u00a0 \u00a0 \u00a0 will retain SSL and TCP and maybe HTTP state for the duration of \u00a0 \u00a0 \u00a0 the session, and the TCP state could potentially include the flow \u00a0 \u00a0 \u00a0 label. are simply variations of application aware proxy they could just as easy be imap(s) or smtp(s) or sip. The operative issue being that for the purposes of connection termination they are hosts not routers and they have to find the upper layer header (and potentially go as far as application protocol implementation). ... \u00a0 \u00a0 \u00a0 In all cases, the layer 3/4 load balancer has to \u00a0 \u00a0 \u00a0 recognize incoming packets as belonging to new or existing client \u00a0 \u00a0 \u00a0 sessions, and choose the target server or proxy so as to ensure \u00a0 \u00a0 \u00a0 persistence. I get what you're trying to say but I think this is a a mis-statement. As you go on to deal with stateless load balancing correctly... A stateless L3+L4 load balancer doesn't care whether a connection is new or preexisting, persistence is product of the values associated with the hash being immutable over the duration for which they are required and no other condition. ... 1.\u00a0 Balancers use various techniques to redirect traffic to a \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 specific target server. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - All servers are configured with the same IP address, they \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 are all on the same LAN, and the load balancer sends directly \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to their individual MAC addresses.\u00a0 In this case, return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets from the server to the client are sent back without \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 passing through the balancer, a technique known as direct \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 server return, but we are not concerned here with the return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer uses an \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IP-in-IP tunnel to reach it. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 performs NAPT (network address and port translation) to \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 deliver the client's packets to that address. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 The choice between these methods is not affected by use of the \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 flow label. You missed one that is rather common which is that there are multiple L3 next-hops\u00a0 for the same destination IP (Layer-3 ECMP the same as is used to hash across router links). that's anycast in it's simplest form, and it's a pretty common technique using either bgp or an IGP of your choice. ... jjaeggli@ca2-b2-re1# run show route 2620:102:8003:211::1/128 inet6.0: 14896 destinations, 59622 routes (14896 active, 0 holddown, 29172 hidden) + = Active Route, - = Last Active, * = Both 2620:102:8003:211::1/128 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  *[BGP/170] 17w6d 23:34:12, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::8 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:21, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:28, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:06, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:08, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:27, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 1d 05:58:20, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:34:38, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:33:43, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 20:20:44, MED 50, localpref 200, from 2620:102:8003::1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 ... \u00a0 \u00a0 \u00a0 2.\u00a0 A layer 3/4 balancer must correctly handle Path MTU Discovery \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 by forwarding relevant ICMPv6 packets in both directions. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 This too is not affected by use of the flow label. icmp messages (this applies to v4 and v6) emitted by devices on the path from the server --> client that are sent back to the server IP are really problematic because the probability of them hashing to a different server is rather high, icmp messages emitted towards the client by path elements inclusive of the server ip are generally no problem. There are techniques to address that e.g. multicasting them towards the servers but that's rather non-scalable. One could snarf the flow label and the destination off the offending packet (the one that's going back in the icmp6 type 2 payload to the sender) and use those as the source\u00a0 and flow label for your icmpv6 ptb message since label-balance would insure delivery but that makes diagnostics kind of sketchy. ... diagram in section 3 \u00a0 \u00a0 \u00a0 \u00a0  ___|_______DNS-based____________|___ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  load splitting\u00a0 \u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  (if used) occurs\u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  here\u00a0 \u00a0  dns based sever selection is actually something that occurs on a nameserver (the GTM) the client (e.g. when more than one record is served) or both e.g. by a GTM serving more that one RR. mb-aye:~ jjaeggli$ host  www.google.com www.google.com  has address 173.194.33.18 www.google.com  has address 173.194.33.16 www.google.com  has address 173.194.33.20 www.google.com  has address 173.194.33.19 www.google.com  has address 173.194.33.17 www.google.com  has IPv6 address 2607:f8b0:400a:800::1010 .... \u00a0  However, usage by the proxies seems unlikely to be cost-effective, \u00a0  because they must in any case process the application layer header, \u00a0  so in this document we focus only on layer 3/4 balancers. As you note previously the flow label is in a fixed location in the\u00a0 ip header, so cost isn't really that germain. They do have to look all the way in-to the application so it may not be that relevant. ... \u00a0  o\u00a0 We are only concerned with IPv6 traffic in which the flow label \u00a0 \u00a0 \u00a0 value has been set at or near the source according to [ RFC6437 ]. I can't see that it matters so long as it doesn't change midflow,\u00a0 it's hard to know this with certainty since it's not immutable. ... section 4 \u00a0 2-tuple {source address, flow label}  What would be the gain in not using the source/dest/flow label on a stateless LB? you may be asserting that the dest has low entropy and maybe it does if you only have one, but if you have hundreds or thousands it may well. The destination is required for the forwarding decision your might as well xor-across it too (and traditional layer-3 only load balancing in v4 typically used at least source/dest and generally protocol number). doing so has no state. ... \u00a0 \u00a0 \u00a0 A stateful layer 3/4 load balancer would apply its usual load \u00a0 \u00a0 \u00a0 distribution algorithm to the first packet of a session, and store \u00a0 \u00a0 \u00a0 the {2-tuple, server} association in a table so that subsequent \u00a0 \u00a0 \u00a0 packets belonging to the same session are forwarded to the same \u00a0 \u00a0 \u00a0 server.\u00a0 Thus, for all subsequent packets of the session, it can \u00a0 \u00a0 \u00a0 ignore all IPv6 extension headers, which should lead to a \u00a0 \u00a0 \u00a0 performance benefit.\u00a0 Whether this benefit is valuable will depend \u00a0 \u00a0 \u00a0 on engineering details of the specific load balancer. This strikes me as a bit odd, as described it would be trivial to multiplex another connection\u00a0 over this state entry (which might be desirable for some applications) simply by using the same source/dest/flow label which sounds like a huge DOS risk e.g. because you now have a fixed state entry pinned to a server so long as you keep sending packets.\u00a0 It might also allow you bypass controls that you could apply to the first packet of each session, like for example initiating a new connection to a different destination port number. The other question is how do you know when the session ends. since you're not looking for fin/ack/fin/ack or RST your basically stuck keeping state with a timer or this state table will always be full. This is not as the security considerations section states: \u00a0 The flow label does not significantly alter this situation. with regard to dos/bypass risk. Rather techniques used today by stateful l3/l4 load balancers to mitigate dos risk statelessly to protect servers from large packet flows e.g. TCP syn cookies or apply gross security controls e.g. only port 80 connections for example) become ineffective because the attacker generating valid connections can know in advance what source/dest/flow label(s) will be used by to create connections through which packets can be delivered to servers (which is a rather different problem then it being hard to guess what someone else is using).  ... \u00a0  Since the \u00a0  only state to be stored is the 2-tuple and the server identifier, \u00a0  storage requirements will be reduced.  and a timer apparently, either the 2 minute one from 3697 if we consider that still in force since 6437 doesn't mention it, or some other one.  ... \u00a0 The association between the flow label value and \u00a0  the server is stored in a table (often called stick table) so that \u00a0  future connections using the same flow label can be sent to the same \u00a0  server. This presumes the reuse of flow labels by a client. while 6437 presumes the existence of stateful flow label usage models, state entries that\u00a0 last a long time relative to the tcp connections that use them are an expensive proposition for a network device.",
        "type": "Discuss"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2013-11-14 21:39:25-08:00",
        "end_reason": "position_updated",
        "start": "2013-11-03 08:54:20-08:00",
        "text": "I'm satisfied with the proposed text changes and will clear when the document is revved. thanks joel this\u00a0 started as a comment. it's bloomed into a discuss because I think there's a lot of issues to be dicussed. (sorry, one minor edit, read the second discuss email rather than the first) \u00a0  If the flow label is in fact set to zero, it will not \u00a0  affect the information entropy of the IPv6 header. certainly it will, since your assumption vis-a-vis label balancing is that it does augment (an l3 only hash)\u00a0 or\u00a0 substitute for entropy that might otherwise be found elsewhere, e.g. in the transport header. Assume the case of load balancing a small number of sources to a single or small number of destination IPs (this is common for API services for example or lots of front-end --> back-backend application communication). host 1 first tcp connection to dest 1 with a zero flow label using a source, dest, flow label, xor hashes to the same host behind dest 1 as host 1 second connection to dest 2 with a zero flow label. That's peachy if that's what you want, but not if you don't. so as you note if you're using zero you probably want to do something else. ... these two: \u00a0 o\u00a0 Another method, for HTTP servers, is to operate a layer 7 reverse \u00a0 \u00a0 \u00a0 proxy in front of the server farm.\u00a0 The reverse proxy will present \u00a0 \u00a0 \u00a0 a single IP address to the world, communicated to clients by a \u00a0 \u00a0 \u00a0 single AAAA record.\u00a0 For each new client session (an incoming TCP \u00a0 \u00a0 \u00a0 connection and HTTP request), it will pick a particular server and \u00a0 \u00a0 \u00a0 proxy the session to it.\u00a0 The act of proxying should be more \u00a0 \u00a0 \u00a0 efficient and less resource-intensive than the act of serving the \u00a0 \u00a0 \u00a0 required content.\u00a0 The proxy must retain TCP state and proxy state \u00a0 \u00a0 \u00a0 for the duration of the session.\u00a0 This TCP state could, \u00a0 \u00a0 \u00a0 potentially, include the incoming flow label value. \u00a0  o\u00a0 A component of some load balancing systems is an SSL reverse proxy \u00a0 \u00a0 \u00a0 farm.\u00a0 The individual SSL proxies handle all cryptographic aspects \u00a0 \u00a0 \u00a0 and exchange unencrypted HTTP with the actual servers.\u00a0 Thus, from \u00a0 \u00a0 \u00a0 the load balancing point of view, this really looks just like a \u00a0 \u00a0 \u00a0 server farm, except that it's specialised for HTTPS.\u00a0 Each proxy \u00a0 \u00a0 \u00a0 will retain SSL and TCP and maybe HTTP state for the duration of \u00a0 \u00a0 \u00a0 the session, and the TCP state could potentially include the flow \u00a0 \u00a0 \u00a0 label. are simply variations of application aware proxy they could just as easy be imap(s) or smtp(s) or sip. The operative issue being that for the purposes of connection termination they are hosts not routers and they have to find the upper layer header (and potentially go as far as application protocol implementation). ... \u00a0 \u00a0 \u00a0 In all cases, the layer 3/4 load balancer has to \u00a0 \u00a0 \u00a0 recognize incoming packets as belonging to new or existing client \u00a0 \u00a0 \u00a0 sessions, and choose the target server or proxy so as to ensure \u00a0 \u00a0 \u00a0 persistence. I get what you're trying to say but I think this is a a mis-statement. As you go on to deal with stateless load balancing correctly... A stateless L3+L4 load balancer doesn't care whether a connection is new or preexisting, persistence is product of the values associated with the hash being immutable over the duration for which they are required and no other condition. ... 1.\u00a0 Balancers use various techniques to redirect traffic to a \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 specific target server. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - All servers are configured with the same IP address, they \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 are all on the same LAN, and the load balancer sends directly \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to their individual MAC addresses.\u00a0 In this case, return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets from the server to the client are sent back without \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 passing through the balancer, a technique known as direct \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 server return, but we are not concerned here with the return \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 packets. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer uses an \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IP-in-IP tunnel to reach it. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - Each server has its own IP address, and the balancer \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 performs NAPT (network address and port translation) to \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 deliver the client's packets to that address. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 The choice between these methods is not affected by use of the \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 flow label. You missed one that is rather common which is that there are multiple L3 next-hops\u00a0 for the same destination IP (Layer-3 ECMP the same as is used to hash across router links). that's anycast in it's simplest form, and it's a pretty common technique using either bgp or an IGP of your choice. ... jjaeggli@ca2-b2-re1# run show route 2620:102:8003:211::1/128 inet6.0: 14896 destinations, 59622 routes (14896 active, 0 holddown, 29172 hidden) + = Active Route, - = Last Active, * = Both 2620:102:8003:211::1/128 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  *[BGP/170] 17w6d 23:34:12, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::8 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:21, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::13 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:28, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::14 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:06, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::15 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:08, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 7w4d 01:55:27, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::18 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 1d 05:58:20, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::19 via ae0.1721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:34:38, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::9 via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 23:33:43, MED 50, localpref 200 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:201::a via ae1.2721 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [BGP/170] 17w6d 20:20:44, MED 50, localpref 200, from 2620:102:8003::1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS path: 64999 I, validation-state: unverified \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 > to 2620:102:8003:200::16 via ae0.1721 ... \u00a0 \u00a0 \u00a0 2.\u00a0 A layer 3/4 balancer must correctly handle Path MTU Discovery \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 by forwarding relevant ICMPv6 packets in both directions. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 This too is not affected by use of the flow label. icmp messages (this applies to v4 and v6) emitted by devices on the path from the server --> client that are sent back to the server IP are really problematic because the probability of them hashing to a different server is rather high, icmp messages emitted towards the client by path elements inclusive of the server ip are generally no problem. There are techniques to address that e.g. multicasting them towards the servers but that's rather non-scalable. One could snarf the flow label and the destination off the offending packet (the one that's going back in the icmp6 type 2 payload to the sender) and use those as the source\u00a0 and flow label for your icmpv6 ptb message since label-balance would insure delivery but that makes diagnostics kind of sketchy. ... diagram in section 3 \u00a0 \u00a0 \u00a0 \u00a0  ___|_______DNS-based____________|___ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  load splitting\u00a0 \u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  (if used) occurs\u00a0  | \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  |\u00a0 \u00a0  here\u00a0 \u00a0  dns based sever selection is actually something that occurs on a nameserver (the GTM) the client (e.g. when more than one record is served) or both e.g. by a GTM serving more that one RR. mb-aye:~ jjaeggli$ host  www.google.com www.google.com  has address 173.194.33.18 www.google.com  has address 173.194.33.16 www.google.com  has address 173.194.33.20 www.google.com  has address 173.194.33.19 www.google.com  has address 173.194.33.17 www.google.com  has IPv6 address 2607:f8b0:400a:800::1010 .... \u00a0  However, usage by the proxies seems unlikely to be cost-effective, \u00a0  because they must in any case process the application layer header, \u00a0  so in this document we focus only on layer 3/4 balancers. As you note previously the flow label is in a fixed location in the\u00a0 ip header, so cost isn't really that germain. They do have to look all the way in-to the application so it may not be that relevant. ... \u00a0  o\u00a0 We are only concerned with IPv6 traffic in which the flow label \u00a0 \u00a0 \u00a0 value has been set at or near the source according to [ RFC6437 ]. I can't see that it matters so long as it doesn't change midflow,\u00a0 it's hard to know this with certainty since it's not immutable. ... section 4 \u00a0 2-tuple {source address, flow label}  What would be the gain in not using the source/dest/flow label on a stateless LB? you may be asserting that the dest has low entropy and maybe it does if you only have one, but if you have hundreds or thousands it may well. The destination is required for the forwarding decision your might as well xor-across it too (and traditional layer-3 only load balancing in v4 typically used at least source/dest and generally protocol number). doing so has no state. ... \u00a0 \u00a0 \u00a0 A stateful layer 3/4 load balancer would apply its usual load \u00a0 \u00a0 \u00a0 distribution algorithm to the first packet of a session, and store \u00a0 \u00a0 \u00a0 the {2-tuple, server} association in a table so that subsequent \u00a0 \u00a0 \u00a0 packets belonging to the same session are forwarded to the same \u00a0 \u00a0 \u00a0 server.\u00a0 Thus, for all subsequent packets of the session, it can \u00a0 \u00a0 \u00a0 ignore all IPv6 extension headers, which should lead to a \u00a0 \u00a0 \u00a0 performance benefit.\u00a0 Whether this benefit is valuable will depend \u00a0 \u00a0 \u00a0 on engineering details of the specific load balancer. This strikes me as a bit odd, as described it would be trivial to multiplex another connection\u00a0 over this state entry (which might be desirable for some applications) simply by using the same source/dest/flow label which sounds like a huge DOS risk e.g. because you now have a fixed state entry pinned to a server so long as you keep sending packets.\u00a0 It might also allow you bypass controls that you could apply to the first packet of each session, like for example initiating a new connection to a different destination port number. The other question is how do you know when the session ends. since you're not looking for fin/ack/fin/ack or RST your basically stuck keeping state with a timer or this state table will always be full. This is not as the security considerations section states: \u00a0 The flow label does not significantly alter this situation. with regard to dos/bypass risk. Rather techniques used today by stateful l3/l4 load balancers to mitigate dos risk statelessly to protect servers from large packet flows e.g. TCP syn cookies or apply gross security controls e.g. only port 80 connections for example) become ineffective because the attacker generating valid connections can know in advance what source/dest/flow label(s) will be used by to create connections through which packets can be delivered to servers (which is a rather different problem then it being hard to guess what someone else is using).  ... \u00a0  Since the \u00a0  only state to be stored is the 2-tuple and the server identifier, \u00a0  storage requirements will be reduced.  and a timer apparently, either the 2 minute one from 3697 if we consider that still in force since 6437 doesn't mention it, or some other one.  ... \u00a0 The association between the flow label value and \u00a0  the server is stored in a table (often called stick table) so that \u00a0  future connections using the same flow label can be sent to the same \u00a0  server. This presumes the reuse of flow labels by a client. while 6437 presumes the existence of stateful flow label usage models, state entries that\u00a0 last a long time relative to the tcp connections that use them are an expensive proposition for a network device.",
        "type": "Discuss"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-11-14 21:39:25-08:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Martin Stiemerling": [
      {
        "ad": "Martin Stiemerling",
        "end": "2013-10-04 04:01:42-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-04 04:01:42-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Pete Resnick": [
      {
        "ad": "Pete Resnick",
        "end": "2013-10-09 20:13:49-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Pete Resnick",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-09 20:13:49-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Richard Barnes": [
      {
        "ad": "Richard Barnes",
        "end": "2013-10-08 08:44:26-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Richard Barnes",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-08 08:44:26-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Sean Turner": [
      {
        "ad": "Sean Turner",
        "end": "2013-10-10 08:29:45-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Sean Turner",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-10 08:29:45-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Spencer Dawkins": [
      {
        "ad": "Spencer Dawkins",
        "end": "2013-10-07 13:20:31-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Spencer Dawkins",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-07 13:20:31-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Stephen Farrell": [
      {
        "ad": "Stephen Farrell",
        "end": "2013-10-10 06:32:41-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-10 06:32:41-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Stewart Bryant": [
      {
        "ad": "Stewart Bryant",
        "end": "2013-10-09 21:51:14-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stewart Bryant",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-09 21:51:14-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Ted Lemon": [
      {
        "ad": "Ted Lemon",
        "end": "2013-10-03 06:58:24-07:00",
        "end_reason": "new_position",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Ted Lemon",
        "end": "2013-11-15 13:48:57-08:00",
        "end_reason": "evaluation_closed",
        "start": "2013-10-03 06:58:24-07:00",
        "text": null,
        "type": "Yes"
      }
    ]
  },
  "doc_name": "rfc7098",
  "evaluation_end": "2013-11-15 13:48:57-08:00",
  "evaluation_start": "2013-10-03 06:58:24-07:00"
}