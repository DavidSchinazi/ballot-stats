{
  "all_ballots": {
    "Adrian Farrel": [
      {
        "ad": "Adrian Farrel",
        "end": "2013-04-29 07:34:44-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Adrian Farrel",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-29 07:34:44-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Barry Leiba": [
      {
        "ad": "Barry Leiba",
        "end": "2013-04-17 08:56:57-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Barry Leiba",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Benoit Claise": [
      {
        "ad": "Benoit Claise",
        "end": "2013-05-16 07:25:09-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Benoit Claise",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-16 07:25:09-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Brian Haberman": [
      {
        "ad": "Brian Haberman",
        "end": "2013-04-23 08:27:35-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Brian Haberman",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-23 08:27:35-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Gonzalo Camarillo": [
      {
        "ad": "Gonzalo Camarillo",
        "end": "2013-05-16 04:55:32-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Gonzalo Camarillo",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-16 04:55:32-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Jari Arkko": [
      {
        "ad": "Jari Arkko",
        "end": "2013-05-16 06:48:11-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Jari Arkko",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-16 06:48:11-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Joel Jaeggli": [
      {
        "ad": "Joel Jaeggli",
        "end": "2013-04-24 22:45:55-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Joel Jaeggli",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-24 22:45:55-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Martin Stiemerling": [
      {
        "ad": "Martin Stiemerling",
        "end": "2013-04-24 01:00:38-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-04-24 02:22:17-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-04-24 01:00:38-07:00",
        "text": "A well-written document and I have a few points to discuss, but I still need to write them in a comprehensive way.  A tentative short list: 1) IPv6 UDP checksum calculation It is not clear if zero UDP checksums are permitted or not permitted with COAP.? (UDP zero checksums:  https://datatracker.ietf.org/doc/draft-ietf-6man-udpzero/ ) That should be specified.  2) Handling of UDP-lite Can UDP-lite ( RFC 3828 ) be used or cannot be used in conjunction with CoAP?",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-05-15 12:21:32-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-04-24 02:22:17-07:00",
        "text": "A well-written document and I have a few points to discuss.  The congestion avoidance mechanisms look ok, but I assume we will get feedback from implementers and deployments on the parameters and mechanisms. It would be good to get this feedback documented at some point.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1) IPv6 UDP checksum calculation It is not clear if zero UDP checksums are permitted or not permitted with COAP.? (UDP zero checksums: https://datatracker.ietf.org/doc/draft-ietf-6man-udpzero/ ) That should be specified. 2) Handling of UDP-lite Can UDP-lite ( RFC 3828 ) be used or cannot be used in conjunction with CoAP? 3) Fragmentation of messages The recommendation in Section 4.6 about the path MTU is generally valid only for IPv6. For IPv4, 567 bytes is the safe area to work without fragmentation, though in today WANs 1280 work perfectly, but I am not so sure about the networks envisioned for CoAP. This 576 bytes for IPv4 are mentioned in the implementation note, but deserves text on the same level as for IPv6.  4) Ensuring no fragmentation with IPv4 The implementation note in Section 4.6 states that for IPv4 it is 'harder to ensure that there is no IP fragmentation'. This neglects the possibility of using the Don't Fragment (DF) flag in the IPv4 header and also that there is possibly feedback from a node enroute that the MTU is too big if the DF flag is set, i.e., by means of an ICMP error message.  Should there be any recommendation or protocol machinery to deal with path probing? E.g., referencing  RFC 4821  (PMTUD).  5) Reaction to network errors that are signalled I wonder why the draft is not discussing any reaction to network failures signalled through ICMP messages. This relates also to my DISCUSS issue no 4.  6) Idempotency The discussion of idempotency is useful, but overlooks message order. I.e., the discussion appears to assume that a sequence of the same actions has the same effect as a single action, but this is true only if different sets of actions (from different sources, or copies of different actions from a single source) aren't interleaved. This should be addressed.  7) Protocol reactions to reserved or prohibited values Regarding reserved or prohibited values in the IANA section, it would be useful to be clear about what happens when those values are seen. I.e., should they be ignored, generate an error, etc. 8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  According to Section 2.1, a node can always return a RST if the message cannot be process for whatever reason.  I propose to add an option to the RST message that allows the message receiver to state how much data it is willing to accept from a particular sender or in general (up to the implementation).\u00a0  9) Handling a wrapping message IDs According to Section 4.4.: \"The same Message ID MUST NOT be re-used (in communicating with the same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2)\" with EXCHANGE_LIFETIME of 247s.  By now it is unrealistic that the message ID of 16 bits will wrap around in that time frame, but protocols live long and at some later time it can be possible.  However, the protocol doesn't have any means to detect wrapped message IDs.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-06-03 06:15:14-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-05-15 12:21:32-07:00",
        "text": "A well-written document and I have a few points to discuss.  The congestion avoidance mechanisms look ok, but I assume we will get feedback from implementers and deployments on the parameters and mechanisms. It would be good to get this feedback documented at some point.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1) IPv6 UDP checksum calculation It is not clear if zero UDP checksums are permitted or not permitted with COAP.? (UDP zero checksums: https://datatracker.ietf.org/doc/draft-ietf-6man-udpzero/ ) That should be specified. 2) Handling of UDP-lite Can UDP-lite ( RFC 3828 ) be used or cannot be used in conjunction with CoAP? 3) Fragmentation of messages The recommendation in Section 4.6 about the path MTU is generally valid only for IPv6. For IPv4, 567 bytes is the safe area to work without fragmentation, though in today WANs 1280 work perfectly, but I am not so sure about the networks envisioned for CoAP. This 576 bytes for IPv4 are mentioned in the implementation note, but deserves text on the same level as for IPv6.  4) Ensuring no fragmentation with IPv4 The implementation note in Section 4.6 states that for IPv4 it is 'harder to ensure that there is no IP fragmentation'. This neglects the possibility of using the Don't Fragment (DF) flag in the IPv4 header and also that there is possibly feedback from a node enroute that the MTU is too big if the DF flag is set, i.e., by means of an ICMP error message.  Should there be any recommendation or protocol machinery to deal with path probing? E.g., referencing  RFC 4821  (PMTUD).  5) Reaction to network errors that are signalled I wonder why the draft is not discussing any reaction to network failures signalled through ICMP messages. This relates also to my DISCUSS issue no 4.  6) Idempotency done. 7) Protocol reactions to reserved or prohibited values Regarding reserved or prohibited values in the IANA section, it would be useful to be clear about what happens when those values are seen. I.e., should they be ignored, generate an error, etc. 8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  According to Section 2.1, a node can always return a RST if the message cannot be process for whatever reason.  I propose to add an option to the RST message that allows the message receiver to state how much data it is willing to accept from a particular sender or in general (up to the implementation).\u00a0  9) Handling a wrapping message IDs According to Section 4.4.: \"The same Message ID MUST NOT be re-used (in communicating with the same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2)\" with EXCHANGE_LIFETIME of 247s.  By now it is unrealistic that the message ID of 16 bits will wrap around in that time frame, but protocols live long and at some later time it can be possible.  However, the protocol doesn't have any means to detect wrapped message IDs.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-06-03 06:31:07-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-06-03 06:15:14-07:00",
        "text": "A well-written document and I have a few points to discuss.  The congestion avoidance mechanisms look ok, but I assume we will get feedback from implementers and deployments on the parameters and mechanisms. It would be good to get this feedback documented at some point.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1) IPv6 UDP checksum calculation -- fixed. 2) Handling of UDP-lite\u00a0 -- fixed. 3) Fragmentation of messages The recommendation in Section 4.6 about the path MTU is generally valid only for IPv6. For IPv4, 567 bytes is the safe area to work without fragmentation, though in today WANs 1280 work perfectly, but I am not so sure about the networks envisioned for CoAP. This 576 bytes for IPv4 are mentioned in the implementation note, but deserves text on the same level as for IPv6.  4) Ensuring no fragmentation with IPv4\u00a0 -- fixed. 5) Reaction to network errors that are signalled I wonder why the draft is not discussing any reaction to network failures signalled through ICMP messages. This relates also to my DISCUSS issue no 4.  6) Idempotency\u00a0 -- fixed. 7) Protocol reactions to reserved or prohibited values Regarding reserved or prohibited values in the IANA section, it would be useful to be clear about what happens when those values are seen. I.e., should they be ignored, generate an error, etc. 8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  According to Section 2.1, a node can always return a RST if the message cannot be process for whatever reason.  I propose to add an option to the RST message that allows the message receiver to state how much data it is willing to accept from a particular sender or in general (up to the implementation).\u00a0  9) Handling a wrapping message IDs According to Section 4.4.: \"The same Message ID MUST NOT be re-used (in communicating with the same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2)\" with EXCHANGE_LIFETIME of 247s.  By now it is unrealistic that the message ID of 16 bits will wrap around in that time frame, but protocols live long and at some later time it can be possible.  However, the protocol doesn't have any means to detect wrapped message IDs.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-06-06 02:10:13-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-06-03 06:31:07-07:00",
        "text": "A well-written document and I have a few points to discuss.  The congestion avoidance mechanisms look ok, but I assume we will get feedback from implementers and deployments on the parameters and mechanisms. It would be good to get this feedback documented at some point.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1) IPv6 UDP checksum calculation -- fixed. 2) Handling of UDP-lite\u00a0 -- fixed. 3) Fragmentation of messages -- done. 4) Ensuring no fragmentation with IPv4\u00a0 -- done. 5) Reaction to network errors that are signalled I wonder why the draft is not discussing any reaction to network failures signalled through ICMP messages. This relates also to my DISCUSS issue no 4.  6) Idempotency\u00a0 -- done. 7) Protocol reactions to reserved or prohibited values Regarding reserved or prohibited values in the IANA section, it would be useful to be clear about what happens when those values are seen. I.e., should they be ignored, generate an error, etc. 8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  The 4.13 \"Request Entity Too Large\" with a protocol field that indicates the maximum data size would be fixing this.  9) Handling a wrapping message IDs According to Section 4.4.: \"The same Message ID MUST NOT be re-used (in communicating with the same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2)\" with EXCHANGE_LIFETIME of 247s.  By now it is unrealistic that the message ID of 16 bits will wrap around in that time frame, but protocols live long and at some later time it can be possible.  However, the protocol doesn't have any means to detect wrapped message IDs.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-06-06 02:11:07-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-06-06 02:10:13-07:00",
        "text": "A well-written document and I have a few points to discuss.  The congestion avoidance mechanisms look ok, but I assume we will get feedback from implementers and deployments on the parameters and mechanisms. It would be good to get this feedback documented at some point.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1)\u00a0 done. 2) done. 3) done. 4) done. 5) done. 6) Idempotency\u00a0 -- done. 7) done.  8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  The 4.13 \"Request Entity Too Large\" with a protocol field that indicates the maximum data size would be fixing this.  9) done.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-07-01 05:36:53-07:00",
        "end_reason": "position_updated",
        "start": "2013-06-06 02:11:07-07:00",
        "text": "Updated based on - 17.  A well-written document and I have a few points to discuss.  Here are the issues (based on my own review and input from Joe Touch and Michael Scharf): 1)\u00a0 done. 2) done. 3) done. 4) done. 5) done. 6)\u00a0 done. 7) done.  8) Flow Control/Receiver Buffer The protocol does not have any real means for the receiver to control the amount of data that is being sent to it. I can understand the attempt to provide a simple protocol, but adding a very basic flow control mechanism will not prohibitively increase the complexity of the protocol, while improving robustness.  The 4.13 \"Request Entity Too Large\" with a protocol field that indicates the maximum data size would be fixing this.  9) done.",
        "type": "Discuss"
      },
      {
        "ad": "Martin Stiemerling",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-07-01 05:36:53-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Pete Resnick": [
      {
        "ad": "Pete Resnick",
        "end": "2013-04-22 15:21:39-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Pete Resnick",
        "end": "2013-05-27 17:05:45-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-04-22 15:21:39-07:00",
        "text": "The items here are very borderline in my book for DISCUSS items; I'm happy to be talked out of them. But I would like to hear from the authors and/or chairs before I give my \"YES\" (which is my plan once these are resolved). 4.1: \u00a0  An empty message has the Code field set to 0.\u00a0 The Token Length field \u00a0  MUST be set to 0 and no bytes MUST be present after the Message ID \u00a0  field.\u00a0 If there are any bytes, they MUST be processed as a message \u00a0  format error. \u00a0   If you insist on the MUSTs, make the second one \"bytes of data MUST NOT be present\". The current construction is ambiguous. That said, I find the combination of MUSTs to be a bit problematic. MUST NOT send data, but MUST receive as a format error will lead to some sender saying, \"A conformant receiver MUST reject with an error, so no need for me to validate on the way out\" and for a receiver to say, \"A conformant sender MUST NOT send data, so no need for me to validate on the way in.\" That's a recipe for non-interoperability. If it were me, I'd drop the last sentence. 4.3: \u00a0  rejecting a Non-confirmable message MAY involve sending a matching \u00a0  Reset message, and apart from the Reset message the rejected message \u00a0  MUST be silently ignored. See comment on 2.1. But if you're going to allow this, I don't understand the MAY: Doesn't rejecting the message require sending a Reset? Otherwise, the message has not been rejected; it's simply been ignored. The second part is either redundant or confusing: What else might I do with a rejected message other than send the Reset and ignore it? I think this needs rewriting. 5.2.2: It is probably worth saying somewhere in here: \"Once the server sends back an empty Acknowledgement, it MUST NOT send back the response in another Acknowledgement, even if the client retransmits another identical request. If a retransmitted request is received (perhaps because the original Acknowledgement was delayed), another empty Acknowledgement is sent and any response MUST be sent as a separate response.\" 5.4.2: Cache-Key is undefined, here or in any other document I can find. It probably needs an explanation somewhere in this document. 5.5: Again, I don't like the combination of MUST NOT include/MUST ignore. I would drop the MUST ignore part. 5.10.4: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 The server SHOULD \u00a0  return the preferred Content-Format if available.\u00a0 If the preferred \u00a0  Content-Format cannot be returned, then a 4.06 \"Not Acceptable\" \u00a0  SHOULD be sent as a response. What are the exceptions to the above two SHOULDs? If the preferred format is available, when would a server not return it. If it's not available, when would the server return other than \"Not Acceptable\"? Also, since Accept is not marked as \"Critical\", why isn't it *always* treated as elective and therefore ignored if the server can't satisfy the request? (In other words, shouldn't you also have a \"Critical Accept\" option defined?)",
        "type": "Discuss"
      },
      {
        "ad": "Pete Resnick",
        "end": "2013-06-28 11:55:55-07:00",
        "end_reason": "position_updated",
        "start": "2013-05-27 17:05:45-07:00",
        "text": "I'm still worried about 5.10.4: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 The server SHOULD \u00a0  return the preferred Content-Format if available.\u00a0 If the preferred \u00a0  Content-Format cannot be returned, then a 4.06 \"Not Acceptable\" \u00a0  SHOULD be sent as a response. The possibility that a server could potentially not send back a 4.06 seems really problematic from a client perspective. I have no way as a client to say, \"I really can only accept format X, and if you can't make format X, I don't want something else\", and I have no way to distinguish that from \"I would prefer format X, but am willing to take whatever you can give me.\" For the former, I have to be prepared to throw things away. For the latter, I have to be willing to send two requests, the first with Accept (potentially getting back 4.06), and then a re-request without Accept. Which one of the above are current clients doing? If it's the former, then I suggest making this into an implementation note, and I would even consider getting rid of the 4.06 response code\u00a0 for this use case, since it is nearly useless, and probably harmful. If it's the latter, then these SHOULDs ought to be MUSTs and the option should be critical so that clients can stop doing that.",
        "type": "Discuss"
      },
      {
        "ad": "Pete Resnick",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-06-28 11:55:55-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Richard Barnes": [
      {
        "ad": "Richard Barnes",
        "end": "2013-04-24 20:21:07-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Richard Barnes",
        "end": "2013-05-15 09:06:48-07:00",
        "end_reason": "position_updated",
        "start": "2013-04-24 20:21:07-07:00",
        "text": "Overall, this is a very nicely written specification.\u00a0 Thanks!\u00a0 There's just one point I think needs action on before I switch to a \"YES\" position. In Section 5.3.1, \"A client sending a request...\".\u00a0 This needs to be stronger.\u00a0 The requirement for a randomized token needs to be a MUST, and the stack SHOULD limit the number of rejected responses (before closing the request) based on the length of the token (e.g., 2**(TKL/2)).",
        "type": "Discuss"
      },
      {
        "ad": "Richard Barnes",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-15 09:06:48-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Sean Turner": [
      {
        "ad": "Sean Turner",
        "end": "2013-05-15 23:29:23-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Sean Turner",
        "end": "2013-07-08 07:35:24-07:00",
        "end_reason": "position_updated",
        "start": "2013-05-15 23:29:23-07:00",
        "text": "Thanks for a clear draft.\u00a0 Makes things so much easier to review.\u00a0 Just want to discuss a couple of things before moving to yes (hopefully). 0) s9.1.3.2: Before I get in to the nitty-gritty of the specific concerns I have with DTLS use of Raw Public Keys, I have to ask whether use of the DTLS client_certificate_url extension was considered?\u00a0 If raw public keys is just about size then that'd work wouldn't it.\u00a0 If you're about dumping processing of paths, then that's another thing. 1) s9.1.3.2.1: What's really hung me up on this draft is the raw public key option.\u00a0 Primarily, the TLS draft is not quite done yet; I'm still in discussions with the authors.\u00a0 Two issues that affect your draft: a)\u00a0  By  draft-ietf-tls-oob-pubkey  taking a pass on specifying all of the ways an identity can be bound to a public key, it leaves it up to the application to specify that mechanism.\u00a0 This binding is important because you can't get peer authentication without it; I'm really worried that if this mode gets widely deployed people will say they have \"DTLS security\" but few (if any) are actually do the work necessary to bind the identity to the key.\u00a0 \u00a0 So, you specify that binding in the provisioning section (good ;) but I want to make sure that it's clear who's doing what to whom: i) s9.1.3.2.1: For machines it's perfect appropriate to generate the key and install it because we doubt it'll be able to do that well enough right (i.e., crummy entropy sources)?\u00a0 I want to make it clear that that's been done by the manufacturer.  In this mode the device has an asymmetric key pair but without an  X.509 certificate (called a raw public key).   to:  In this mode the device has an asymmetric key pair but without an  X.509 certificate (called a raw public key); the asymmetric key  paid is generated by the manufacturer and installed on the device. ii) s9.1.3.2.1: This draft does that binding using Stephen's naming thing with hashes, but I want to make sure that it's clear who is identifier, it now says: \u00a0 An identifier is calculated \u00a0 from the public key as described in Section 2 of [ RFC6920 ].  Is it the  \u00a0 An identifier is calculated by the endpoint from \u00a0 from the public key as described in Section 2 of [ RFC6920 ].  b)  draft-ietf-tls-oob-pubkey  is likely to take a pass on specifying a mechanism for revoking the public key and identity binding.\u00a0 Note that ocsp-/multi-ocsp staplingwon't work because there's no way to request information about a certificate that you don't have information about.\u00a0  I'm not trying to gold plate the security mechanism here but I think we need some words on how revocation for this mode will be handled.\u00a0 However, I suspect you'll want to use the ACLs....there's a mechanism for including ACLs during provisioning but is there a way to update them later?\u00a0 What happens if a new node gets installed or removed?\u00a0 Is there a requirement for ACLs to be supported; the text has a SHOULD but that seems to be about ACL provisioning support not ACL support. 2) s9.1.3.2: Another TLS-related issue: When referring to TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 please include the MTI curve(s).\u00a0 Ever so glad that conservative curves are being used.\u00a0 In the following, I assumed you'd want the one must and the two mays but I can understand if you don't.\u00a0 I'd argue you do have algorithm agility with DTLS so you could get away with just the MUST ad not the MAYs. Unrelated to you, but I thought I'd let you know about: the curve requirements will almost certainly be removed from the mcgrew draft at my direction because no other D/TLS EC cipher suite specifies an MTI curve.\u00a0 There's support for conservative curves, but not enough interest in starting to add MTI curves instead of the application picking them.\u00a0 Note the Zigbee folks also point to the mcgrew draft but it seems their drafts already include the curves so we ought to be good to go on both fronts. I think we need to be clear that choosing this particular cipher suite that it means an implementation needs to support the extensions defined in  RFC 4492  - or if it doesn't.\u00a0 I'm assuming you want it to so I'm going to propose some tweaking: OLD: \u00a0 Implementations in \u00a0 RawPublicKey mode MUST support the mandatory to implement cipher \u00a0 suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified in \u00a0 [ I-D.mcgrew-tls-aes-ccm-ecc ], [ RFC5246 ], [ RFC4492 ].  NEW: \u00a0 Implementations in \u00a0 RawPublicKey mode MUST support the mandatory to implement \u00a0 cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified \u00a0 in [ I-D.mcgrew-tls-aes-ccm-ecc ].\u00a0  The key used MUST be \u00a0 ECDSA-capable; the curve secp256r1 MUST \u00a0 be supported, and the curves secp384r1 and secp521r1 MAY be \u00a0 supported [ RFC4492 ]; these curves are equivalent to the \u00a0 NIST P-256, P-384, and P-521 curves. Implementations MUST \u00a0 use/support (?) the Supported Elliptic Curves Extension and \u00a0 Supported Point Format extensions [ RFC4492 ]; the uncompressed \u00a0 point format MUST be supported; [ RFC6090 ] can be used as an \u00a0 implementation method. The mcgrew draft had the following instead of the last sentence so I'm open to whichever but I think something about the folllowing needs to be added:  o The uncompressed point format MUST be supported.\u00a0 Other point \u00a0  formats MAY be used.  o The client SHOULD offer the elliptic_curves extension and the \u00a0  server SHOULD expect to receive it.  o The client MAY offer the ec_point_formats extension, but the \u00a0  server need not expect to receive it.  o [ RFC6090 ] MAY be used as an implementation method.   And then, I think we need to specify how the MTI would look: namely by adding the following on to the end of the paragraph. \u00a0 When the mandatory to implement DTLS cipher suite and curve and \u00a0 used the SubjectPublicKeyInfo indicates an algorithm of \u00a0 id-ecPublicKey with the namedCurves object identifier set to \u00a0 secp256r1 [ RFC5480 ].\u00a0  If secp384r1 or secp521r1 are used the \u00a0 those object identifiers [ RFC5480 ] are included instead.  \u00a0  That way everybody knows what values go in the SPKI of the oob-pubkey draft.\u00a0 Note they tried to change that field recently and I had to remind them not to. 3) s9:\u00a0 I know we're all about be liberal in what you accept, but in this context that might be challengeing; this bit:  ... all modes of DTLS may not be  applicable.\u00a0 Some DTLS cipher suites can add significant  implementation complexity as well as some initial  handshake overhead  needed when setting up the security association. Made me wonder whether you considered which other DTLS extensions might be useful in addition to the EC ones and SNI as well as what extensions should be profiled out?\u00a0 For example, max_fragment_length looks pretty useful in this context as well as certificate_url.\u00a0 But does heartbeat make any sense? 4) s8: I think you need to make it pretty darn clear in s8 that multi-cast is an unsecured \"mode\" as specified in this document.\u00a0 It's kind of buried in s9. 5) s9.1.2: (worried about a DoS attack) Do you mean that responses to secured-CoAP messages returned unsecured are silently discarded/ignored or rejected and then that kicks off an error code response? 6) s9.1.3.1: Did you consider whether there should be an application profile for the psk_identity_hint (see Section 5 [ RFC4279 ]) - i.e., is there a standard format for CoAP that should be defined? 7) s9.1.3.3: When you say \"the Certificate must be validated\" I'm just checking that you're think there's going to be a certificate chain?\u00a0 If there's no chain the validation rules in 5280 don't apply. 8) s9: If you're going to allow more than two entities to share the preshared keys I think it's worth pointing out you really can't get peer authentication with either CoAP or DTLS.\u00a0 The description in s9 and elsewhere seems to imply that more than one peer might share the same key. 9) Either in s9 or s11 we need to say something about devices with bad entropy sources not bothering to make keys because they won't be of any use.\u00a0  If they've got bad entropy sources the manufacturer or whoever should be making the keys.",
        "type": "Discuss"
      },
      {
        "ad": "Sean Turner",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-07-08 07:35:24-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Spencer Dawkins": [
      {
        "ad": "Spencer Dawkins",
        "end": "2013-05-15 10:45:14-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Spencer Dawkins",
        "end": "2013-05-20 23:12:34-07:00",
        "end_reason": "position_updated",
        "start": "2013-05-15 10:45:14-07:00",
        "text": "Note that I plan to ballot Yes, after we resolve these questions.  I have three points - the first one is the one I'm most curious about.  In 4.8.1.\u00a0 Changing The Parameters \u00a0  It is recommended that an \u00a0  application environment use consistent values for these parameters. I'm thinking about this in an IOT/M2M context where it's somewhere between inconvenient and impossible to change parameters on all the deployed devices at once. I understand that configuring these parameters is out of scope for the doc, so assume changing the parameters is out of scope as well. If you start deploying new devices into that environment with significantly different parameters, is it more likely that performance would suffer, or that something would break? (I don't care what the answer is, I'd just like for the reader to have one - do you HAVE to get the parameters right the first time, or do you WANT to get them right, but you can deploy new devices with different parameters and let the old devices be removed/replaced over time?) This one is on the edge of being a Comment:  In 5.10.5.\u00a0 Max-Age \u00a0  The value is intended to be current at the time of transmission. \u00a0  Servers that provide resources with strict tolerances on the value of \u00a0  Max-Age SHOULD update the value before each retransmission. Will servers know that resources they serve have strict tolerances? The answer may be \"yes\", I'm just asking. If not, I'm wondering if this should be a MUST. This one is on the edge of being a comment:  In 7.2.\u00a0 Resource Discovery \u00a0  The discovery of resources offered by a CoAP endpoint is extremely \u00a0  important in machine-to-machine applications where there are no \u00a0  humans in the loop and static interfaces result in fragility.\u00a0 A CoAP \u00a0  endpoint SHOULD support the CoRE Link Format of discoverable \u00a0  resources as described in [ RFC6690 ]. Is it obvious that this is a SHOULD? Is CoRE Link Format necessary for resource discovery, or can you also accomplish this with humans if they're in the loop? I'm just trying to wrap my head around \"it's extremely important but implementations might not do it\".",
        "type": "Discuss"
      },
      {
        "ad": "Spencer Dawkins",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-20 23:12:34-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Stephen Farrell": [
      {
        "ad": "Stephen Farrell",
        "end": "2013-04-24 18:25:54-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2013-05-13 09:16:20-07:00",
        "end_reason": "discuss_updated",
        "start": "2013-04-24 18:25:54-07:00",
        "text": "I will end up balloting yes for his. I think its good work and has lots of implementations. Note also that some of the discuss points here should be easily resolved or are just checking stuff. (Its in the nature of very very long documents that the accumulation of such stuff generates more discuss points.) Anyway, let's discuss... (1) 2.3: What if the URI scheme doesn't have a host or port or path or query?\u00a0 Also in 5.6, 2nd bullet in list: Just to note that if you were using ni URIs with CoAP, then you no longer need to insist on exactly the same URI (e.g. the authority part needn't matter with ni URIs, the alg-val part is what counts). That might be true of other schemes too, so perhaps this statment is scheme specific to some extent? This is just a discuss point to check that you're ok with CoAP being restricted to some URI schemes in this manner, the ni URI case is just an example I happen to know fairly well:-) So I'll clear this one when told that this is considered acceptable but I want to check the general issue about uri-scheme dependencies for CoAP. The same point occurs in 5.7.1 and maybe elsewhere btw. So basic point is: please provide some sensible description of which URI schemes can be used with CoAP and which cannot. (2) 4.2, \"when the timeout is triggered\" - what happens with sleepy nodes that only wake on external events, and where e.g. if 2 timeouts have elapsed whilst asleep? Not sure if odd behaviour of that kind could cause much harm, but was it considered? This could also affect the definition in 4.8.2 of MAX_TRANSMIT_SPAN. (3) 4.2, last para: this creates an attack that can work from off-path - just send loads of faked ACKs with guessed Tokens and some of 'em will be accepted with probability depending on Token-length and perhaps the quality of the RNG used by the sender of the CON. That could cause all sorts of \"interesting\" application layer behaviour. Why is that ok? (Or put another way - was this considered and with what conclusion?) I suspect you need to have text trading off the Token length versus use of DTLS or else CoAP may end up too insecure for too many uses. (Note: the attack here is made worse because the message ID comparison can be skipped. Removing that \"feature\" would help a lot here.) 5.3.1's client \"may want to use a non-trivial, randomized token\" doesn't seem to cut it to me. How does this kind of interaction map to DTLS sessions/epoch? Basically, I'd like to see some RECOMMENDED handling of token length that would result in it not being unsafe to connect a CoAP node to the Internet. (And please note recent instances where 10's of thousands of insecure devices have been found via probing the IPv4 address space. These are real attacks.) (4) 4.4, implementation note - this seems unwise since it means that once Alice has interacted with Bob, then Bob can easily guess the message IDs that Alice will use to talk to Charlie. (5) 4.6, last para\u00a0 - this only applies to insecure uses of CoAP, you should point that out (6) 6.2 - \"the UDP datagrams MUST...use DTLS\" is fine but maybe not enough, if the request uses DTLS then presumably so MUST *all* response messages, and they MUST use the same DTLS session? Or perhaps one with the same authenticated endpoints. Don't you need to say that? If you don't then just sending the request via DTLS but getting (some) response messages in clear would seem to be allowed.\u00a0 I think 9.1 might cover all the above, but want to just check. (7) 9.1.1, 1st para: what is \"the server\" - is that the destination host from the URI? If yes, then fine.\u00a0 If no, then we need to DISCUSS that.  (8) 9.1.3.3 - \"signed by an appropriate chain of trust\" is an odd phrase - do you mean it MUST be validated as per  RFC 5280  section 6? If so, say so. If not, say what you do mean. (But we might need to talk about it in that case, depending;-) (9) 9.1.3.3 - you don't mention certificate status checking. I can see why that's hard to impossible in some n/w's but entirely ignoring it seems wrong. Perhaps call out the vulnerability and point at OCSP stapling as a potential solution, but one that requires further work and/or further specification? (10) 10.1 - what does https mean here? If it means that the request/response are in clear between the source and proxy and then encrypted then a) you really really need to say that clearly and b) why is that even acceptable and c) what if the destination resource requires client auth? It just seems broken to pretend to use https this way. Going via a cross-proxy breaks security.\u00a0 Similarly, what does coaps mean in 10.2?",
        "type": "Discuss"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2013-05-26 13:54:15-07:00",
        "end_reason": "position_updated",
        "start": "2013-05-13 09:16:20-07:00",
        "text": "I will (still:-) end up balloting yes for his.  Just one DISCUSS point remaining. (1) Cleared, but see comment below (2) Cleared.  (3) Cleader, but see comment below. (4) Cleared, but see comment below. (5) Cleared. (6) Cleared. (7) Cleared. (8) Cleared. (9) Cleared. (10) 10.1 - what does https mean here? If it means that the request/response are in clear between the source and proxy and then encrypted then a) you really really need to say that clearly and b) why is that even acceptable and c) what if the destination resource requires client auth? It just seems broken to pretend to use https this way. Going via a cross-proxy breaks security.\u00a0 Similarly, what does coaps mean in 10.2? We had some mail exchanges about that, but I'm not sure I'm ok with the outcome so I'd like to DISCUSS this some more. (And did any of that get into  -16? Not sure.)",
        "type": "Discuss"
      },
      {
        "ad": "Stephen Farrell",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-05-26 13:54:15-07:00",
        "text": null,
        "type": "Yes"
      }
    ],
    "Stewart Bryant": [
      {
        "ad": "Stewart Bryant",
        "end": "2013-04-24 09:12:31-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Stewart Bryant",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-24 09:12:31-07:00",
        "text": null,
        "type": "No Objection"
      }
    ],
    "Ted Lemon": [
      {
        "ad": "Ted Lemon",
        "end": "2013-04-24 20:32:13-07:00",
        "end_reason": "new_position",
        "start": "2013-04-17 08:56:57-07:00",
        "text": null,
        "type": "No Record"
      },
      {
        "ad": "Ted Lemon",
        "end": "2013-07-15 09:50:30-07:00",
        "end_reason": "evaluation_closed",
        "start": "2013-04-24 20:32:13-07:00",
        "text": null,
        "type": "No Objection"
      }
    ]
  },
  "doc_name": "rfc7252",
  "evaluation_end": "2013-07-15 09:50:30-07:00",
  "evaluation_start": "2013-04-17 08:56:57-07:00"
}